<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Software Engineering Study Guide</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A study guide for software engineering interviews">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="general_knowledge/general_knowledge.html"><strong aria-hidden="true">1.</strong> General Knowledge</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="general_knowledge/asymptotic_analysis.html"><strong aria-hidden="true">1.1.</strong> Asymptotic Analysis</a></li><li class="chapter-item expanded "><a href="general_knowledge/security_cryptography.html"><strong aria-hidden="true">1.2.</strong> Security and Cryptography</a></li></ol></li><li class="chapter-item expanded "><a href="data_structures/data_structures.html"><strong aria-hidden="true">2.</strong> Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data_structures/data_types/data_types.html"><strong aria-hidden="true">2.1.</strong> Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data_structures/data_types/primitive_types.html"><strong aria-hidden="true">2.1.1.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="data_structures/data_types/composite_types.html"><strong aria-hidden="true">2.1.2.</strong> Composite Types</a></li><li class="chapter-item expanded "><a href="data_structures/data_types/abstract_data_types.html"><strong aria-hidden="true">2.1.3.</strong> Abstract Data Types</a></li></ol></li><li class="chapter-item expanded "><a href="data_structures/linear_data_structures.html"><strong aria-hidden="true">2.2.</strong> Linear Data Structures</a></li><li class="chapter-item expanded "><a href="data_structures/graphs.html"><strong aria-hidden="true">2.3.</strong> Graphs</a></li><li class="chapter-item expanded "><a href="data_structures/trees.html"><strong aria-hidden="true">2.4.</strong> Trees</a></li></ol></li><li class="chapter-item expanded "><a href="algorithms/algorithms.html"><strong aria-hidden="true">3.</strong> Algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithms/top_level.html"><strong aria-hidden="true">3.1.</strong> Top-Level</a></li><li class="chapter-item expanded "><a href="algorithms/combinatorics.html"><strong aria-hidden="true">3.2.</strong> Combinatorics</a></li><li class="chapter-item expanded "><a href="algorithms/graph_tree.html"><strong aria-hidden="true">3.3.</strong> Graph &amp; Tree</a></li><li class="chapter-item expanded "><a href="algorithms/sequence.html"><strong aria-hidden="true">3.4.</strong> Sequence</a></li><li class="chapter-item expanded "><a href="algorithms/sorting.html"><strong aria-hidden="true">3.5.</strong> Sorting</a></li><li class="chapter-item expanded "><a href="algorithms/other.html"><strong aria-hidden="true">3.6.</strong> Other</a></li></ol></li><li class="chapter-item expanded "><a href="data_stores/data_stores.html"><strong aria-hidden="true">4.</strong> Data Stores</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data_stores/relational_databases.html"><strong aria-hidden="true">4.1.</strong> Relational Databases</a></li><li class="chapter-item expanded "><a href="data_stores/nosql.html"><strong aria-hidden="true">4.2.</strong> NoSQL</a></li></ol></li><li class="chapter-item expanded "><a href="design_patterns/design_patterns.html"><strong aria-hidden="true">5.</strong> Design Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design_patterns/creational.html"><strong aria-hidden="true">5.1.</strong> Creational</a></li><li class="chapter-item expanded "><a href="design_patterns/structural.html"><strong aria-hidden="true">5.2.</strong> Structural</a></li><li class="chapter-item expanded "><a href="design_patterns/behavioral.html"><strong aria-hidden="true">5.3.</strong> Behavioral</a></li><li class="chapter-item expanded "><a href="design_patterns/functional.html"><strong aria-hidden="true">5.4.</strong> Functional</a></li><li class="chapter-item expanded "><a href="design_patterns/concurrency.html"><strong aria-hidden="true">5.5.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="design_patterns/architectural.html"><strong aria-hidden="true">5.6.</strong> Architectural</a></li><li class="chapter-item expanded "><a href="design_patterns/cloud_distributed.html"><strong aria-hidden="true">5.7.</strong> Cloud Distributed</a></li><li class="chapter-item expanded "><a href="design_patterns/testing.html"><strong aria-hidden="true">5.8.</strong> Testing</a></li><li class="chapter-item expanded "><a href="design_patterns/other.html"><strong aria-hidden="true">5.9.</strong> Other</a></li><li class="chapter-item expanded "><a href="design_patterns/anti_patterns.html"><strong aria-hidden="true">5.10.</strong> Anti-Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="interview_prep/interview_prep.html"><strong aria-hidden="true">6.</strong> Interview Prep</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interview_prep/personal_anecdotal_questions.html"><strong aria-hidden="true">6.1.</strong> Personal/Anecdotal Questions</a></li><li class="chapter-item expanded "><a href="interview_prep/occupational_questions/occupational_questions.html"><strong aria-hidden="true">6.2.</strong> Occupational Questions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interview_prep/occupational_questions/short_answer.html"><strong aria-hidden="true">6.2.1.</strong> Short Answer</a></li><li class="chapter-item expanded "><a href="interview_prep/occupational_questions/whiteboard.html"><strong aria-hidden="true">6.2.2.</strong> Whiteboard</a></li></ol></li><li class="chapter-item expanded "><a href="interview_prep/questions_to_ask.html"><strong aria-hidden="true">6.3.</strong> Questions To Ask</a></li></ol></li><li class="chapter-item expanded "><a href="other_resources.html">Other Resources</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Software Engineering Study Guide</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome. You've found my study guide. With the help of some friends I've created a guide encapsulating most of the knowledge I've found necessary for interviews in my personal experience, as well as things I've learned may be necessary from a variety of books related to software engineering interviews.</p>
<p>Beyond interview prep, this can also be a good reference for anyone in school trying to study for their data structures, algorithms, or design patterns courses.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-knowledge"><a class="header" href="#general-knowledge">General Knowledge</a></h1>
<h3 id="bitwise-operations"><a class="header" href="#bitwise-operations">Bitwise Operations</a></h3>
<ul>
<li>&amp; = AND</li>
<li>| = OR</li>
<li>~ = NOT</li>
<li>^ = XOR</li>
<li>&lt;&lt; = left shift (new bits are 0)</li>
<li>&gt;&gt; = right shift (new bits are 0)</li>
</ul>
<h3 id="bit-manipulation-tricks"><a class="header" href="#bit-manipulation-tricks">Bit Manipulation Tricks</a></h3>
<ul>
<li>Check if an integer is even</li>
</ul>
<pre><code>return x &amp; 1 == 0;
</code></pre>
<ul>
<li>Check if an integer is a power of 2</li>
</ul>
<pre><code>return x &amp;&amp; !(x &amp; (x - 1));
</code></pre>
<ul>
<li>Swap two numbers</li>
</ul>
<pre><code>a = 1; b = 2;
a = a ^ b;
b = a ^ b;
a = a ^ b;
// a = 2, b = 1
</code></pre>
<ul>
<li>Flip the bits of an integer (language-dependent)</li>
</ul>
<pre><code>int allOnes = ConvertToInt(&quot;111...&quot;); // use as many 1s as there are bits in x
return allOnes - x;
</code></pre>
<h3 id="http-request-methods"><a class="header" href="#http-request-methods">HTTP Request Methods</a></h3>
<ul>
<li>GET = Retrieve data.</li>
<li>HEAD = GET, but without the response body (just the metadata and header).</li>
<li>POST = Tell a URI to handle some data.</li>
<li>PUT = Set the resource at the given URI.</li>
<li>DELETE = Delete the specified resource.</li>
</ul>
<p>There are others, but these are the most commonly used.</p>
<h3 id="git-commands"><a class="header" href="#git-commands">Git Commands</a></h3>
<ul>
<li>init - creates a new local repository</li>
<li>clone - downloads an existing project/repo</li>
<li>diff - shows unstaged file differences</li>
<li>commit - records the current state of files to version history</li>
<li>reset - undoes all commits after the provided one</li>
<li>branch - creates a new branch</li>
<li>checkout - switches to a specified branch</li>
<li>merge / mergetool - combine target branches</li>
<li>stash - temporarily store current file changes</li>
<li>fetch - downloads repo history</li>
<li>pull - downloads branch history</li>
<li>push - uploads local branch commits</li>
</ul>
<p>There are others, but these are the most commonly used.</p>
<h3 id="memory"><a class="header" href="#memory">Memory</a></h3>
<p>Memory can be allocated on the stack or the heap.</p>
<p>Stack allocation happens in a contiguous block of memory, and the compiler pre-determines the required space.</p>
<p>Heap allocation happens during the execution of the program as per the instructions of the programmer. </p>
<p>The key difference is that programmers are responsible for allocating and deallocating heap memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asymptotic-analysis"><a class="header" href="#asymptotic-analysis">Asymptotic Analysis</a></h1>
<h2 id="big-o-notation"><a class="header" href="#big-o-notation">Big-O Notation</a></h2>
<p>Asymptotic analysis is usually expressed in Big-O notation. This notation is usually used to describe the upper bound on a growth rate.</p>
<p>Formally, it is said that \( f(x) = O(g(x)) \) if there exists a positive real number \( m \) such that \( \left\lvert f(x) \right\rvert \leq m \cdot g(x) \) as \( x \to \infty \). Alternatively, \( f(x) = O(g(x)) \) if such an \( m \) exists that makes \( \lim_{x \to \infty} \frac{\left\lvert f(x) \right\rvert}{m \cdot g(x)} \lt \infty \) true.</p>
<p>For example: \( x^2 \) is \( O\left(x^3\right) \) and \( 4x^2 + 3x + 2 \) is \( O\left(x^2\right) \).</p>
<h2 id="other-notations"><a class="header" href="#other-notations">Other Notations</a></h2>
<p>Big-\( \Omega \) notation can be interpreted as the &quot;opposite&quot; of Big-O notation in computer science; \( f(x) = \Omega(g(x)) \) if and only if \( g(x) = O(f(x)) \). Alternatively, \( f(x) = \Omega(g(x)) \) if there exists a positive real number \( m \) such that \( \lim_{x \to \infty} \frac{f(x)}{m \cdot g(x)} \gt 0 \).</p>
<p>For example: \( x^3 \) is \( \Omega\left(8x^2\right) \). It is also possible for the second example above to hold: \( 4x^2 + 3x + 2 \) is \( \Omega\left(x^2\right) \).</p>
<p>Big-\( \Theta \) notation is defined simply as: \( f(x) = \Theta(g(x)) \) if and only if \( f(x) = O(g(x)) = \Omega(g(x)) \).</p>
<p>Using the example above: \( 4x^2 + 3x + 2 \) is \( \Theta\left(x^2\right) \).</p>
<h2 id="algorithm-analysis"><a class="header" href="#algorithm-analysis">Algorithm Analysis</a></h2>
<p>In computer science, Big-O notation is commonly used to describe the performance of algorithms, either in terms of run time or memory usage. Usually when run time or memory usage are analyzed, we want to know the worst-case, so we make the assumption that conditional statements always pass. Take the following function for example:</p>
<pre><code>def myFunc(someArray)
{
    count = 0;

    foreach (element in someArray)
    {
        if (element != null)
            count = count + 1;
    }
}
</code></pre>
<p>Line-by-line:</p>
<ul>
<li><code>count = 0;</code> is an assignment operation, and has a constant run time, so this is an \( O(1) \) operation.</li>
<li><code>foreach (element in someArray)</code> loops through each element of the array, so this tells us that whatever happens inside this loop will happen n times, where n is the length of the array.</li>
<li><code>if (element != null)</code> is a conditional statement (constant time) using an equality comparer (also constant time), thus an \( O(1) \) operation.</li>
<li><code>count = count + 1;</code> is an assignment and increment (both constant time). Since we're analyzing the worst case scenario, we assume this will always be hit, even though it's only conditionally hit in practice. Either way, it is an \( O(1) \) operation.</li>
</ul>
<p>In total, we have a run time of \( O(1) + (O(n) \cdot (O(1) + O(1))) \). This can be condensed to \( O(1 + (n \cdot (1 + 1))) = O(1 + n) = O(n) \).</p>
<p>If we were to add another for loop inside the existing one then we would get a runtime of \( O\left(n^2\right) \), and so on.</p>
<h3 id="amortized-analysis"><a class="header" href="#amortized-analysis">Amortized Analysis</a></h3>
<p>An alternative to worst-case performance analysis is amortized analysis, which is roughly &quot;average-case&quot; performance analysis. There are 3 primary methods to analyze an algorithm like this:</p>
<ol>
<li>Run the algorithm \( n \) times with different inputs, calculating their operational costs each time. Take the upper bound of the sum of all operational costs and divide by \( n \).</li>
<li><a href="https://en.wikipedia.org/wiki/Accounting_method_(computer_science)">The accounting method</a></li>
<li><a href="https://en.wikipedia.org/wiki/Potential_method">The potential method</a></li>
</ol>
<p>Amortized analysis is usually how certain performance gains are found, especially when the possible input set of an algorithm is limited. For example, quick sort is the most commonly implemented sorting algorithm, but it's actually faster to sort a mostly sorted collection using insertion sort. Similarly, quick sort in and of itself has a worst-case of \( O(n) \), even though it's <em>usually</em> more performant than other sorting algorithms with better worst-case analyses.</p>
<h3 id="the-master-theorem"><a class="header" href="#the-master-theorem">The Master Theorem</a></h3>
<p>Sometimes it is difficult to analyze algorithms, especially when they implement recursion, such as in Divide &amp; Conquer algorithms. This is where the master theorem comes into play. Divide &amp; Conquer algorithms can be expressed as \[ T(n) = a \cdot T\left(\frac{n}{b}\right) + f(n) \] where \( T(n) \) is an upper bound on the run time of the algorithm, \( n \) is the input size, \( a \) is the number of recursive calls that each individual call makes, \( \frac{n}{b} \) is the input size of the recursive calls, and \( f(n) \) is the the run time of the final call (the base case). Additionally, let \( c_{crit} = \frac{\log(number of subproblems)}{\log(relative subproblem size)} = \log_b a \).</p>
<p>Given the above, the master theorem says that</p>
<ul>
<li>If there exists a \( c \lt c_{crit} \) such that \( f(n) = O\left(n^c\right) \), then \( T(n) = \Theta\left(n^{\log_b a}\right) \).</li>
<li>If there exists a \( k \geq 0 \) such that \( f(n) = \Theta\left(n^{c_{crit}} log^k n\right) \), then \( T(n) = \Theta\left(n^{c_{crit}} log^{k+1} n \right) \).</li>
<li>If there exists a \( c \gt c_{crit} \) such that \( f(n) = \Omega\left(n^c\right) \), <em>and</em> there exists a \( k \lt 1 \) and sufficiently large \( n \) such that \( a \cdot f\left(\frac{n}{b}\right) \leq k \cdot f(n) \), then \( T(n) = \Theta(f(n)) \).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-and-cryptography"><a class="header" href="#security-and-cryptography">Security and Cryptography</a></h1>
<p>Most people in the industry aren't designing cyptography algorithms, but there's some value in knowing the uses for the various popular cryptography algorithms and cryptographic schemes in the same way that there's value in knowing some basic malicious attacks against software software systems.</p>
<h3 id="sha"><a class="header" href="#sha">SHA</a></h3>
<p>An acronym for Secure Hash Algorithms, SHA is a family of cryptographic hash functions, which means that they turn data of arbitrary size into a fixed-size bit array. They are impractical to reverse, and the same data will always result in the same hash, with two values never (or infeasibly) resulting in the same hash. Also, hashes should be unrelated to each other (a small variation in one value should result in a drastically different hash). They are used to verify the integrity of messages and files, as well as for generating and verifying signatures, and verifying passwords. They are also seen used as unique identifiers, and commonly used in software distribution so that users can validate they have the correct file after download by applying the same hash function.</p>
<h3 id="rsa"><a class="header" href="#rsa">RSA</a></h3>
<p>RSA is a public-key cryptosystem--a system in which participants have a public encryption key and a private decryption key. It is most commonly used for symmetric key cryptography (keys used for encrypting plaintext and decrypting ciphertext are the same or one is derivative of the other--both keys are known to all the parties participating in the exchange of information), and for small amounts of data in asymmetric key cryptography, because it is a slow algorithm. The premise of such systems is that a party that wants to send a sensitive message to another party can use the latter's public encryption key so that only the latter can decrypt it with their private key. Such systems can also be used in authentication by using the private keys to create digital signatures on messages, and so the receiver can use the sender's public key to re-encrypt the message with the signature and verify that the result is indeed valid.</p>
<h3 id="diffie-hellman-key-exchange"><a class="header" href="#diffie-hellman-key-exchange">Diffie-Hellman Key Exchange</a></h3>
<p>This is a method of securely exchanging cryptographic keys over a public channel. It is itself non-authenticated, but provides the basis for many authenticated protocols.</p>
<p>An underlying assumption is that reversing the operation \( g^a \mod p \), where <em>a</em> is some integer, <em>p</em> is a prime number, and <em>g</em> is a primitive root modulo <em>p</em> (math terms; more info <a href="https://en.wikipedia.org/wiki/Primitive_root_modulo_n">here</a>), is not practical.</p>
<p>The basic algorithm is as follows:</p>
<ul>
<li>Alice and Bob publicly agree to use some prime <em>p</em> and some primitive root modulo <em>p</em>, <em>g</em>.</li>
<li>Alice secretly chooses an integer, <em>a</em>, and sends Bob the result of \( A = g^a \mod p \).</li>
<li>Bob secretly chooses an integer, <em>b</em>, and sends Alice the result of \( B = g^b \mod p \).</li>
<li>Alice computes the value of \( B^a \mod p \).</li>
<li>Bob computes the value of \( A^b \mod p \).</li>
<li>The values Alice and Bob computed should be the same, and that is their shared secret.</li>
</ul>
<h3 id="hmac"><a class="header" href="#hmac">HMAC</a></h3>
<p>An HMAC is a Hash-based Message Authentication Code, a specific type of code invoving a cryptographic hash function and a secret cryptographic key. It is used to simultaneously verify the data integrity and authenticity of a message. Such codes can be generated with any cryptographic hash functions (like SHA).</p>
<p>The exact definition/calculation for an HMAC is complex. More info <a href="https://en.wikipedia.org/wiki/HMAC">here</a>.</p>
<h3 id="aes"><a class="header" href="#aes">AES</a></h3>
<p>AES is a specification for the encryption of electronic data. It describes a symmetric-key algorithm. In practice it is generally superior to RSA for use in a symmetric system, but can be combined with RSA's asymmetric system capabilities such that data is exchanged encrypted via AES, but getting the secret key required to decrypt that data involves authorized recipients publishing a public key and keeping a private key, the public key of which is then used by the sender with RSA to encrypt and transmit secret AES keys to recipients that they can use to decrypt the data.</p>
<h3 id="hamming-codification"><a class="header" href="#hamming-codification">Hamming Codification</a></h3>
<p>Hamming codes are a family of linear error-correcting codes that can detect up to two-bit errors or correct one-bit errors without detection of uncorrected errors. Parity bits are a similar concept that cannot correct errors and can only detect an odd number of bits in error. More info <a href="https://en.wikipedia.org/wiki/Hamming_code#General_algorithm">here</a>.</p>
<h3 id="cyclic-redundancy-check"><a class="header" href="#cyclic-redundancy-check">Cyclic Redundancy Check</a></h3>
<p>Another error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data. It is named as such because it expands data without adding information and the algorithm is based on cyclic codes therein. More info <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">here</a>.</p>
<h2 id="attack--defense"><a class="header" href="#attack--defense">Attack &amp; Defense</a></h2>
<p>There aren't many common attacks that developers will have to actively defend against on a regular basis. From an application design standpoint you could encourage features such as 2-factor authentication, but at the end of the day it's not up to developers whether or not a feature is added. One attack developers will have to actively defend against is the injection attack. Defending against an injection attack is as simple as not letting user input go unchecked to a database query. This means <em>sanitizing</em> and <em>parameterizing</em> user input. Man-in-the-middle attacks are also something that needs to be addressed by developers. The defense against man-in-the-middle attacks is not letting sensitive information travel between services in a manner that makes the information easy to decrypt. In other words: sensitive information should always be encrypted before crossing services, and encrypted information should not travel with or near any information that could aid in decrypting it. While you might not personally have to deal with either of these things, it's not all that common to see a basic injection attack question in an interview (e.g. &quot;What's wrong with this code?&quot;).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<p>These are fundamental structures in computer science which enable complex operations. This chapter only covers data structures that are significant/well-known in computer science, or that are broadly applicable to most computer science fields. You will not find data structures in this chapter that have very specific, niche use cases, or are only applicable to specific fields of computer science.</p>
<h2 id="cheat-sheet"><a class="header" href="#cheat-sheet">Cheat Sheet</a></h2>
<p>For the lazy among you...</p>
<h3 id="abstract-data-types"><a class="header" href="#abstract-data-types">Abstract Data Types</a></h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)">List</a>: ordered, not necessarily unique, not finite</li>
<li><a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a>: not necessarily ordered, unique, not finite</li>
<li><a href="https://en.wikipedia.org/wiki/Record_(computer_science)">Tuple</a>: ordered, not necessarily unique, finite, a composite type in some (probably most) languages</li>
<li><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a>: first-in-last-out, <code>pop()</code>, <code>push()</code>, <code>peek()</code></li>
<li><a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a>: first-in-first-out, <code>enqueue()</code>, <code>dequeue()</code>, can be prioritized (priority queue)</li>
<li><a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset">Bag</a>: random or full reads only, <code>grab()</code>/<code>pick()</code></li>
<li><a href="https://en.wikipedia.org/wiki/Multimap">Multimap/Associative Array</a>: key-value mappings (e.g. hash table), <code>getValue(key)</code>, <code>insert(key, value)</code></li>
</ul>
<h3 id="performance-tables"><a class="header" href="#performance-tables">Performance Tables</a></h3>
<p>If multiple values, the order is <em>Worst-Case</em> | <em>Amortized</em> .</p>
<h4 id="arrays--lists"><a class="header" href="#arrays--lists">Arrays &amp; Lists</a></h4>
<table>
    <tr>
        <th>Structure</th>
        <th>Indexing</th>
        <th>Insert/Delete [0]</th>
        <th>Insert/Delete [n-1]</th>
        <th>Insert/Delete [i]</th>
        <th>Wasted Space</th>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Array_data_structure">Array</a></td>
        <td>&Theta;(1)</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>N/A</td>
        <td>0</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Dynamic_array">Dynamic Array</a></td>
        <td>&Theta;(1)</td>
        <td>&Theta;(n)</td>
        <td>&Theta;(n) | &Theta;(1)</td>
        <td>&Theta;(n)</td>
        <td>&Theta;(n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Hashed_array_tree">Hashed Array Tree</a>*</td>
        <td>&Theta;(1)</td>
        <td>&Theta;(n)</td>
        <td>&Theta;(n) | &Theta;(1)</td>
        <td>&Theta;(n)</td>
        <td>&Theta;(&#8730;n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Linked_list">Linked List</a></td>
        <td>&Theta;(n)</td>
        <td>&Theta;(1)</td>
        <td>&Theta;(1), &Theta;(n)**</td>
        <td>***</td>
        <td>&Theta;(n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Balanced Tree</a>****</td>
        <td>&Theta;(log n)</td>
        <td>&Theta;(log n)</td>
        <td>&Theta;(log n)</td>
        <td>&Theta;(log n)</td>
        <td>&Theta;(n)</td>
    </tr>
</table>
* Not programmatically a tree, contrary to its name.
<br>
** &Theta;(1) when the last element is known; &Theta;(n) when the last element is unknown.
<br>
*** Insertions/Deletions from the middle of a list are dependent how that element is found (it is &Theta;(n) to simply go to the i<sup>th</sup> element, but searching without knowing the index has a different complexity). There is a &Theta;(1) tax on that algorithm.
<br>
**** Not technically a list structure, but included to compare indexing.
<br>
<br>
<table>
    <tr>
        <th>Structure</th>
        <th>Search</th>
        <th>Insert</th>
        <th>Delete</th>
        <th>Space</th>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Skip_list">Skip List</a></td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
        <td>O(n log n) | O(n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table</a></td>
        <td>O(n) | O(1)</td>
        <td>O(n) | O(1)</td>
        <td>O(n) | O(1)</td>
        <td>O(n)</td>
    </tr>
</table>
<h4 id="trees"><a class="header" href="#trees">Trees</a></h4>
<table>
    <tr>
        <th>Structure</th>
        <th>Search</th>
        <th>Insert</th>
        <th>Delete</th>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Binary_tree">Binary Tree</a></td>
        <td>O(n)</td>
        <td>O(n)</td>
        <td>O(n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Binary_search_tree">Binary Search Tree</a></td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Cartesian_tree">Cartesian Tree</a></td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/K-d_tree">K-D Tree</a></td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
        <td>O(n) | O(log n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/AVL_tree">AVL Tree</a></td>
        <td>O(log n)</td>
        <td>O(log n)</td>
        <td>O(log n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Tree</a></td>
        <td>O(log n)</td>
        <td>O(log n)</td>
        <td>O(log n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Splay_tree">Splay Tree</a></td>
        <td>&Theta;(n) | O(log n)*</td>
        <td>&Theta;(n) | O(log n)</td>
        <td>&Theta;(n) | O(log n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/B-tree">B-Tree</a></td>
        <td>O(log n)</td>
        <td>O(log n)</td>
        <td>O(log n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Trie">Trie</a>**</td>
        <td>O(m)</td>
        <td>O(m)</td>
        <td>O(m)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Van_Emde_Boas_tree">Van Emde Boas Tree</a>***</td>
        <td>O(log m)</td>
        <td>O(log m)</td>
        <td>O(log m)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Radix_tree">Radix Tree</a>**</td>
        <td>O(m)</td>
        <td>O(m)</td>
        <td>O(m)</td>
    </tr>
</table>
* Recently searched values can be found again in O(1) time with splay trees.
<br>
** Tries are a type of associative array, and radix trees are a type of trie. Here, m represents the length of the key.
<br>
*** Van Emde Boas trees are also a type of associative array. Here, m is the bit length of the keys and the maximum number of elements that can be stored in the tree is 2<sup>m</sup>.
<h4 id="heaps"><a class="header" href="#heaps">Heaps</a></h4>
<table>
    <tr>
        <th>Structure</th>
        <th>Find-Min*</th>
        <th>Delete-Min*</th>
        <th>Insert</th>
        <th>Decrease-Key</th>
        <th>Meld</th>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Binary_heap">Binary Heap</a></td>
        <td>&Theta;(1)</td>
        <td>&Theta;(log n)</td>
        <td>O(log n)</td>
        <td>O(log n)</td>
        <td>&Theta;(n)</td>
    </tr>
    <tr>
        <td><a href="https://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci Heap</a></td>
        <td>&Theta;(1)</td>
        <td>O(log n)</td>
        <td>&Theta;(1)</td>
        <td>&Theta;(1)</td>
        <td>&Theta;(1)</td>
    </tr>
</table>
* "Min" here is used to refer to the value with the highest priority (it is what will be at the top of the heap).
<h4 id="graphs"><a class="header" href="#graphs">Graphs</a></h4>
<p>There aren't that many types of graphs, and the most common non-standard type is a flow network.</p>
<p>Graphs can be searched in \( O(\left\lvert V \right\rvert + \left\lvert E \right\rvert) \) time using \( O(\left\lvert V \right\rvert) \) space, where \( \left\lvert V \right\rvert \) and \( \left\lvert E \right\rvert \) are the number of vertices and the number of edges, respectively.</p>
<p>The performance of finding the shortest path between two vertices depends on the type of graph (directed, acyclic, does/does not contain negative edge weights, etc.) and the algorithm used. See more in the algorithms chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>These are the building blocks of complex data structures.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>These are the possible representations of data at any given address.</p>
<p>Somewhat depends on the language, but this is the list Wikipedia uses.</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>True or false.</p>
<h3 id="character"><a class="header" href="#character">Character</a></h3>
<p>Represents a symbol, usually in ASCII.</p>
<p>Interchangeable with integer in some languages.</p>
<h3 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating-Point Numbers</a></h3>
<p>E.G. float, double.</p>
<h3 id="fixed-point-numbers"><a class="header" href="#fixed-point-numbers">Fixed-Point Numbers</a></h3>
<p>E.G. decimal.</p>
<h3 id="integer"><a class="header" href="#integer">Integer</a></h3>
<p>Integral or fixed-precision values.</p>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<p>A.K.A. pointer or handle.</p>
<h3 id="enumerated-type"><a class="header" href="#enumerated-type">Enumerated Type</a></h3>
<p>A small set of uniquely named values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composite-types"><a class="header" href="#composite-types">Composite Types</a></h1>
<p>A.K.A. non-primitive types.</p>
<p>Somewhat depends on the language, but this is the list Wikipedia uses.</p>
<h3 id="array"><a class="header" href="#array">Array</a></h3>
<p>Fixed set of values in adjacent space.</p>
<p>E.G. string (an array of characters).</p>
<p>Indexable in constant (\( \Theta(1) \)) time with no wasted space. An index \( i \) can be modified in constant time as well. Since the length is fixed, insertion and deletion operations don't apply.</p>
<h3 id="record"><a class="header" href="#record">Record</a></h3>
<p>A.K.A. tuple or structure (struct).</p>
<h3 id="union"><a class="header" href="#union">Union</a></h3>
<p>Can have any of several representations or formats within the same position in memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abstract-data-types-1"><a class="header" href="#abstract-data-types-1">Abstract Data Types</a></h1>
<p>These are models defined by their behavior. Their implementations are not prescribed, which is what separates them from data structures and composite data types.</p>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<p>A.K.A. sequence.</p>
<p>Countable, ordered values with no requirement for uniqueness.</p>
<p>Common operations include <code>getElementAt(i)</code>, <code>add(element)</code>, <code>add(element, index)</code>, <code>count()</code>, <code>first()</code> and <code>last()</code>.</p>
<h3 id="multimap"><a class="header" href="#multimap">Multimap</a></h3>
<p>A series of mappings from unique keys to values.<br></p>
<h4 id="associative-array"><a class="header" href="#associative-array">Associative Array</a></h4>
<p>A.K.A. map or dictionary.</p>
<p>A subset of multimaps wherein only one value can be associated with a key.</p>
<h3 id="set"><a class="header" href="#set">Set</a></h3>
<p>Unique, unordered values.</p>
<h3 id="multiset"><a class="header" href="#multiset">Multiset</a></h3>
<p>A.K.A. bag.</p>
<p>Similar to a set, but can allow repeated (equal) values, which can either be treated as identical (counted, but not stored), or equivalent (counted and stored). You could also think of it as similar to a list, but order doesn't matter.</p>
<h3 id="stack"><a class="header" href="#stack">Stack</a></h3>
<p>Like a list, defined by the following behavior:</p>
<ul>
<li><code>push(element)</code> an element by adding it to the front of the list.</li>
<li><code>pop()</code> an element by removing it from the front of the list.</li>
<li><code>peek()</code> by observing the front-most element.</li>
</ul>
<p>The last element to enter the stack will be the first one to leave it.</p>
<h3 id="queue"><a class="header" href="#queue">Queue</a></h3>
<p>Like a list, defined by the following behavior:</p>
<ul>
<li><code>enqueue(element)</code> an element by adding it to the back of the list.</li>
<li><code>dequeue()</code> an element by removing it from the front of the list.</li>
</ul>
<p>The first element to enter the queue will be the first one to leave it.</p>
<h4 id="priority-queue"><a class="header" href="#priority-queue">Priority Queue</a></h4>
<p>A structure defined with the same behavior as a queue, except either the <code>enqueue()</code> operation or the <code>dequeue()</code> operation may re-order elements such that certain elements will leave the queue with a higher priority than other elements (first-in-first-out is not as strictly followed).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-data-structures"><a class="header" href="#linear-data-structures">Linear Data Structures</a></h1>
<h3 id="dynamic-array"><a class="header" href="#dynamic-array">Dynamic Array</a></h3>
<p>This is array that can shrink or expand in size. A somewhat basic implementation of this is creating a new array with length of, for example: 16. When the array becomes full, a new array is created with more spaces (different implementations may create a different amount of spaces), for example: 32. Then, all the values in the old array are copied into the new array. The same operation may happen in reverse if enough values are deleted from the array.</p>
<p>The average cost to insert or delete at a random index is therefore \( \Theta(1) \), but to insert or delete at the beginning or end of the array is \( O(n) \). Dynamic arrays usually waste \( \Omega(n) \) space when expanding.</p>
<h3 id="hashed-array-tree"><a class="header" href="#hashed-array-tree">Hashed Array Tree</a></h3>
<p>Despite the name, this is not really a tree; It's a dynamic array. The difference is that elements are stored as lists. </p>
<p>For example, your base array may start with a capacity of 16. Actually, it would be an array of length 4, where each element is a pointer to another array of length 4. </p>
<p>This approach puts some restrictions on when it can be expanded and shrunk, but it means that you only have to move 4 elements (the pointers) instead of 16 when you do expand it. The insertion and deletion performance of the hashed array tree is therefore the same as in a standard dynamic array, but it only wastes \( O\left(\sqrt n\right) \) space when expanding.</p>
<h3 id="singularly-linked-list"><a class="header" href="#singularly-linked-list">Singularly Linked List</a></h3>
<p>A list that consists of a sequence of nodes, which each contain a value and a reference to the next node in the list (or null if it is the last node).</p>
<ul>
<li>Searchable in \( O(n) \) time (unsorted). Variable when sorted (depends on algorithm).</li>
<li>Reading, inserting or deleting at the end of the list may take \( O(1) \) or \( O(n) \) time, depending on whether the last element is known or not (it is known in most implementations).</li>
<li>Reading, inserting or deleting at the beginning of the list should take \( O(1) \) time.</li>
<li>Insert, delete, or read in the middle of the list in <em>search time</em> + \( \Theta(1) \) (always \( O(i) \) time if acting on index \( i \ne n-1 \)).</li>
</ul>
<h3 id="doubly-linked-list"><a class="header" href="#doubly-linked-list">Doubly Linked List</a></h3>
<p>The main difference between a doubly linked list and a singularly linked list is that nodes also carry a reference to the previous node. This may lend itself to sorting algorithms, and if the last element is known in the implementation, then it will always take at most \( O\left(\frac n 2 \right) \) time to read/insert/delete at a specific index (time is still that of a singularly linked list if looking for an element by value instead of index).</p>
<h3 id="circularly-linked-list"><a class="header" href="#circularly-linked-list">Circularly Linked List</a></h3>
<p>A circularly linked list is simply a linked list where the &quot;next&quot; pointer of the last node points to the first node. There is no substantial performance difference between this and a singularly linked list. A circularly linked list can optionally be implemented with doubly linked nodes, thus gaining the benefits of a doubly linked list.</p>
<h3 id="skip-list"><a class="header" href="#skip-list">Skip List</a></h3>
<p>A skip list is quite a unique list. It is a tiered structure, where each tier is itself a sorted list (commonly a linked list). At the top you have a list with few elements, and as you progress down, the lists gain more and more elements (including the elements from previous tiers). Usually there is some sort of algorithm to determine which elements go in the top tier (usually the most frequently accessed elements end up there). This kind of data structure is known as a probabilistic data structure.</p>
<p>A search through a skip list would start at the top and work its way down when it cannot find the desired element. It goes through elements until it passes from a smaller element to a larger element than the one desired, then it will go down to the next tier and search between those two elements in the that tier, and so on. To go to a specific position it can simply jump to the bottom tier or, if it knows the highest tier that the index is on, it can jump straight to the highest tier with that index.</p>
<p>This kind of list is good for storing data with values of varying importance, such as data following a normal curve.</p>
<p>To achieve the performance benefits of a skip list, you must accept wasted space. A skip list will use \( O(n \log n) \) space in the worst case, but \( O(n) \) on average in exchange for searching, inserting, and deleting in \( O (\log n) \) time on average and \( O(n) \) time in the worst case.</p>
<h3 id="hash-table"><a class="header" href="#hash-table">Hash Table</a></h3>
<p>An implementation of an associative array that passes provided keys through a hash function to determine where in an array they go.</p>
<p>Key collisions can be handled either by implementing the array as an array of lists (multiple keys can map to the same place, but their order is tracked so as to know which value in the list belongs to which key) or by moving the value to the next available space.</p>
<p>Hash tables...</p>
<ul>
<li>do not allow for null keys or values.</li>
<li>are thread-safe, but not performant.</li>
</ul>
<p>Hash tables will use the standard \( O(n) \) space with constant time (\( O(1) \)) searches, insertions, and deletions on average (\( O(n) \) in the worst case).</p>
<h3 id="hash-map"><a class="header" href="#hash-map">Hash Map</a></h3>
<p>This is a volatile variation of the hash table, which...</p>
<ul>
<li>allows nulls for keys and values.</li>
<li>is not thread-safe, but is performant.</li>
</ul>
<h3 id="hash-set"><a class="header" href="#hash-set">Hash Set</a></h3>
<p>A set in which values are passed through a hash function to determine their placement within an array. All other rules of sets are followed (unique, unordered values).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs-1"><a class="header" href="#graphs-1">Graphs</a></h1>
<p>Graphs are collections of vertices (a.k.a. nodes) and edges, where each vertex has a collection of edges it touches, and each edge is composed of a <em>to</em> vertex and a <em>from</em> vertex. They are primarily used for spatial operations or relationship analysis.</p>
<h3 id="directed-graph"><a class="header" href="#directed-graph">Directed Graph</a></h3>
<p>Edges can only be traversed one way. Vertices have their collection of edges split in two: one collection for incoming edges and one collection for outgoing edges.</p>
<h3 id="directed-acyclic-graph"><a class="header" href="#directed-acyclic-graph">Directed, Acyclic Graph</a></h3>
<p>Directed graphs are acyclic if there is no way to traverse from any one vertex back to itself.</p>
<h3 id="flow-networks"><a class="header" href="#flow-networks">Flow Networks</a></h3>
<p>Edges in a flow network are assigned a flow, and each vertex must have the same incoming flow as it has outgoing flow, except for source vertices, which may not have any incoming flow, and sink vertices, which may not have any outgoing flow. Edges are assigned a capacity, and the flow through edges cannot exceed their capacity.</p>
<h3 id="adjacency-list"><a class="header" href="#adjacency-list">Adjacency List</a></h3>
<p>This is a way of representing a graph as a list of node adjacencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trees-1"><a class="header" href="#trees-1">Trees</a></h1>
<p>Trees are basically rooted graphs (interactions with trees begins at the same vertex each time, which is the root).</p>
<p>Some terminology:</p>
<ul>
<li>An element is referred to as a <em>node</em>.</li>
<li>The starting node, with no parent, is called the <em>root</em>.</li>
<li><em>External nodes</em>, or <em>leaves</em> are the nodes with no children. <em>Internal nodes</em> are the opposite.</li>
<li>The <em>height</em> of a tree is the length of the longest path to a leaf from the root.</li>
<li>A tree is <em>balanced</em> if the left and right subtrees of every node differ in height by no more than 1.</li>
</ul>
<p>All trees listed below use \( O(n) \) space.</p>
<p>Trees can have very complex implementations, so the implementations will not all be described here. The important part is knowing which trees are important for which tasks; You can always google the implementation once you know what you need.</p>
<h3 id="binary-tree"><a class="header" href="#binary-tree">Binary Tree</a></h3>
<p>In a binary tree, no node can have more than two child nodes. This leads to some handy properties:</p>
<ul>
<li>The maximum number of nodes at level \( l \) will be \( 2^{l-1} \). Note: The root node is considered to be on level 1.</li>
<li>The maximum number of nodes in a binary tree of height \( h \) is \( 2^h - 1 \). Note: The height of a tree with one node (the root node) is considered to be 1.</li>
<li>In a binary tree with \( n \) nodes, the minimum height is \( \log_2(n+1) \).</li>
</ul>
<p>Many correlaries can be drawn from the aforementioned properties as well.</p>
<p>There are various ways of describing binary trees based on their structure:</p>
<ul>
<li>A <strong>full</strong> binary tree is one in which every node has either 0 or 2 children. Recursively: A full binary tree is either a single node, or a node with 2 children that are each full binary trees.</li>
<li>A <strong>complete</strong> binary tree is one in which every level except the last must be completely filled, and all nodes on the last level must be as far left as possible.</li>
<li>A <strong>perfect</strong> binary tree is one in which all leaves are on the same level.</li>
</ul>
<h3 id="binary-search-tree"><a class="header" href="#binary-search-tree">Binary Search Tree</a></h3>
<p>The basic process of inserting into a binary search tree is as follows:</p>
<pre><code>insert(value)
{
    if root.value == null
        root.value = value
    else if value &lt;= root.value
        root.left.insert(value)
    else
        root.right.insert(value)
}
</code></pre>
<p>The expected height of a binary search tree is \( \sqrt n \).</p>
<p>Searching, inserting, and deleting all take, on average, \( O(\log n) \) time and, at worst, \( O(n) \) time.</p>
<h3 id="avl-tree"><a class="header" href="#avl-tree">AVL Tree</a></h3>
<p>In an AVL tree, the nodes are ordered, from left to right, minimum to maximum, and the tree stays as balanced as possible.</p>
<p>The basic process of inserting is similar to that of a binary search tree, except that after an insertion, the ancestors of the new node are checked for balance and, if they are not balanced, they get re-balanced.</p>
<p>AVL trees are similar to red-black trees in terms of operational performance, but AVL trees are faster for lookup-intensive applications because they are more strictly balanced.</p>
<p>Searching, inserting, and deleting all take \( O(\log n) \) time.</p>
<h3 id="splay-tree"><a class="header" href="#splay-tree">Splay Tree</a></h3>
<p>Splay trees can really use whatever ordering they want, but the important part is that there is an order, because splay trees have the unique behavior of &quot;splaying&quot; once a node is accessed. Splaying enacts a series of rotations/swaps with the accessed node and its parent or siblings, repeatedly, until the accessed node becomes the root node and the tree still adheres to its ordering principle. This means that splay trees are very performant when it is known that some nodes will be need to be accessed much more frequently than others.</p>
<p>Searching, inserting, and deleting all take, on average, \( O(\log n) \) time and, at worst, \( O(n) \) time.</p>
<h3 id="trie"><a class="header" href="#trie">Trie</a></h3>
<p>What makes a tree a trie is if all nodes have a key that is some character to accompany its value. Thus, a traversal through a trie results in a path that creates a unique word/string out of the keys. This also makes it an associative array implementation.</p>
<p>Searching, inserting, and deleting all take \( O(m) \) time, where \( m \) is the length of the word/string being accessed or updated.</p>
<h3 id="cartesian-tree"><a class="header" href="#cartesian-tree">Cartesian Tree</a></h3>
<p>Cartesian trees are heap-ordered (largest values on top, smallest at bottom, or vice-versa) trees generated from a sequence of numbers (each node represents one of the numbers in the sequence) with the unique property that a symmetric (in-order/left-to-right) traversal of the tree will yield the sequence it was generated from. It takes linear time to construct such a tree.</p>
<p>These trees are commonly used for range-searching operations and range minimum queries.</p>
<p>Searching, inserting, and deleting all take, on average, \( O(\log n) \) time and, at worst, \( O(n) \) time.</p>
<h3 id="k-d-tree"><a class="header" href="#k-d-tree">K-D Tree</a></h3>
<p>Every leaf node in a k-d tree represents a k-dimensional point. Each level down the tree splits that point on another dimension. </p>
<p>For example, in a 2-d tree, the root node may represent a 1-dimensional line with the formula \( y = x \). In this tree, every leaf node to the left of the root will represent a point \( (x,y) \) where \( y \lt x \), and every leaf node to the right of it will represent a point where \( y \gt x \). You could keep creating divisions at each level until eventually you make leaf nodes with the actual coordinates of the points.</p>
<p>This type of tree lends itself to range-searching operations and nearest neighbor problems.</p>
<p>Searching, inserting, and deleting all take, on average, \( O(\log n) \) time and, at worst, \( O(n) \) time.</p>
<h3 id="red-black-tree"><a class="header" href="#red-black-tree">Red-Black Tree</a></h3>
<p>In a red-black tree, each node is assigned a color (red or black), and the tree is given a pattern. If that pattern gets broken by an insertion or deletion, then the tree is re-arranged to reform the pattern of colors. Usually the rule is that colors must alternate.</p>
<p>Searching, inserting, and deleting all take \( O(\log n) \) time.</p>
<h3 id="b-tree"><a class="header" href="#b-tree">B-Tree</a></h3>
<p>A B-tree is a non-binary tree that stores nodes in groups and remains balanced. Instead of a node having children, groups of nodes have shared children. This is used for databases and file systems since it is well-suited for storage systems that read and write relatively large blocks of data.</p>
<p>Searching, inserting, and deleting all take \( O(\log n) \) time.</p>
<h3 id="van-emde-boas-tree"><a class="header" href="#van-emde-boas-tree">Van Emde Boas Tree</a></h3>
<p>A unique tree that implements an associative array, whose search time improves as the stored values decrease in bit size.</p>
<p>Searching, inserting, and deleting all take \( O(\log m) \) time, \( m \) is the bit length of the keys, and the maximum number of elements that can be stored in the tree is \( 2^m \).</p>
<h3 id="radix-tree"><a class="header" href="#radix-tree">Radix Tree</a></h3>
<p>A radix tree is a type of trie which is space-optimized. Each node that is an only child is merged with its parent, so instead of a path like g-l-a-d-i-a-t-o-r, you may get a path like g-l-adi-a-to-r.</p>
<p>These share the performance of tries, with some optimizations on searching and some taxes on inserting/deleting.</p>
<p>Searching, inserting, and deleting all take \( O(m) \) time, where \( m \) is the length of the word/string being accessed or updated.</p>
<h3 id="heap"><a class="header" href="#heap">Heap</a></h3>
<p>Heaps are types of trees that are commonly used to implement priority queues. Heaps are almost <em>complete</em> trees, and usually they either sort by low-to-high or high-to-low from top-to-bottom.</p>
<p>Some common operations include:</p>
<ul>
<li>Find-Min (find the highest priority node)</li>
<li>Delete-Min (delete the highest priority node)</li>
<li>Insert</li>
<li>Increase-Key/Decrease-Key (update the priority of a key/node in the tree)</li>
<li>Meld/Merge (join 2 heaps together)</li>
<li>Heapify (turn a list of elements into a heap)</li>
</ul>
<h3 id="binary-heap"><a class="header" href="#binary-heap">Binary Heap</a></h3>
<p>These are simply heaps wherein nodes can only have 2 children.</p>
<p>Finding takes \( \Theta(1) \) time, deleting \( \Theta(\log n) \), inserting and modifying the key \( O(\log n) \), and melding/merging \( \Theta(n) \).</p>
<h3 id="fibonacci-heap"><a class="header" href="#fibonacci-heap">Fibonacci Heap</a></h3>
<p>A fibonacci heap is actually a collection of heap-ordered trees, which maintains its status as a heap by keeping track of the minimum value between all the trees. The sizes of the trees are limited by the fibonacci numbers, hence the name. A fibonacci heap is guaranteed to be more performant than a binary heap in cases where insertions and modifications are more likely to happen than deletions.</p>
<p>Finding, inserting, modifying, and merging should all take \( \Theta(1) \) time, with deletions taking \( O(\log n) \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<p>Algorithms are essentially a way of getting from point A to point B. Therefore, many of the algorithms in this section will be accompanied by some sort of problem or question that the algorithm solves or answers.</p>
<p>In practice, it is unlikely that you will face the exact problems that these algorithms solve, but it's worth knowing them because many problems can be transformed into problems that these algorithms solve. This is the concept behind NP-Hard; A problem is said to be NP-Hard if any problem in NP can be transformed into it in polynomial time. In order to solve an NP-Hard problem, you simply need to know an NP problem, the solution to it, and how to transform it into the NP-Hard problem. The same can philosophy can be extended indefinitely to other, real-world problems, and is not confined to NP-Hard (just because a problem is not NP-Hard does not mean you cannot transform it into another problem you know the answer to).</p>
<p>As with data structures, this chapter only covers algorithms that are significant/well-known in computer science, or that are broadly applicable to most computer science fields. This means, for example, you wont find an algorithm for analyzing pictures of people to determine if they are smiling or frowning, nor will you find algorithms specific to artificial intelligence, meachine learning, etc. This chapter includes, primarily, algorithms that are applicable to most fields of computer science or have some value outside of niche use cases.</p>
<p>Ultimately, just knowing algorithms wont help <em>that</em> much. Here are some places where you can practice applying your knowledge of algorithms:</p>
<ul>
<li>https://projecteuler.net/</li>
<li>https://leetcode.com/</li>
<li>https://www.codewars.com/</li>
<li>https://www.kaggle.com/</li>
</ul>
<p>NOTE: Some algorithms simply have a link to other articles. Such is done for non-essential algorithms which are more valuable to simply know about than to know the implementation for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="top-level"><a class="header" href="#top-level">Top-Level</a></h1>
<p>Top-level algorithms encompass the general approaches to solving problems in computer science. These don't necessarily have an accompanying problem, and they're used as a foundational piece of most common algorithms.</p>
<h3 id="brute-force"><a class="header" href="#brute-force">Brute Force</a></h3>
<p>The most straight-forward approach to problem-solving: Try everything. Many people think of password cracking when they think of brute force algorithms; If you are trying to figure out the passcode to a 4-digit combination lock with no guess limit, you can simply try every combination of 4 digits. Such is the essence of brute force.</p>
<h3 id="greedy-method"><a class="header" href="#greedy-method">Greedy Method</a></h3>
<p>The greedy method is when you &quot;prefer&quot; something in an algorithmic approach to problem solving. </p>
<p>For instance, if you want to maximize the number of items you can take on your trip in your suitcase without concern for their value, you might pack your items in order from smallest to largest. In that case, you are preferring small items, so you're using a greedy method. Such a problem also demonstrates the drawback of the greedy method: Often times, it is not perfect. In that scenario, at some point it may no longer becomes optimal to pack the smallest item because its shape might prevent you from adding anything more, even though 2 slightly larger items would have fit.</p>
<h3 id="divide--conquer"><a class="header" href="#divide--conquer">Divide &amp; Conquer</a></h3>
<p>Like the name suggests, the premise of divide and conquer algorithms is to divide the problem into sub-problems, solve the sub-problems, and then merge the solutions together to form the solution to the initial problem.</p>
<h3 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h3>
<p>Dynamic programming can be difficult to conceptualize, but don't worry, there are examples in other sections of this guide. </p>
<p>Similar to the divide and conquer approach, dynamic programming seeks to define sub-problems and solve them before merging them to create a solution to the base problem. The difference between the two approaches is that dynamic programming requires that the sub-problems are overlapping. </p>
<p>So what, exactly, is an overlapping sub-problem? Consider the Fibonacci series: \( F_i = F_{i-1} + F_{i-2} \), with the base case \( F_1 = F_2 = 1 \). In order to solve for \( F_{10} \) we generate two sub-problems, \( F_{10} = F_9 + F_8 \). We thus need to solve another sub-problem, \( F_9 = F_8 + F_7 \), and so we see that the solution for \( F_{10} \) and \( F_9 \) have an overlapping sub-problem of \( F_8 \) (and \( F_7 \), etc.). If we were to take a divide and conquer approach then we'd be solving \( F _8 \) twice, which dynamic programming seeks to optimize against.</p>
<p>The dynamic programming approach is usually to create a k-dimensional table for sub-problems and their solutions, where k is the number of sub-problems each problem has. There are 2 common ways to go about this:</p>
<ul>
<li>Top-down: Upon observing a sub-problem, check the table to see if it has already been solved. If it has already been solved, then use it, otherwise we solve it and add its solution to the table.</li>
<li>Bottom-up: Create a table of sub-problems, then start at the most refined sub-problem(s) (ones which do not have any further sub-problems, like \( F_1 \) and \( F_2 \) in the Fibonacci series), adding solutions to the table until you arrive at the original problem. </li>
</ul>
<p>The top-down approach may save more space, but you have to check the table for a sub-problem in each step. The bottom-up approach avoids the lookup tax, but might solve more sub-problems than it needs to. The top-down approach is usually done recursively, whereas the bottom-up approach is usually done iteratively. In programming this amounts to whether a function calls itself or whether it uses a <code>for</code> loop.</p>
<h3 id="monte-carlo"><a class="header" href="#monte-carlo">Monte Carlo</a></h3>
<p>This type of algorithm solves a problem by randomly sampling the solutions to related problems. For example: if you know that a certain problem with variables has a solution of 0 5% of the time and a solution of 1 99% of the time, then the monte carlo approach to figuring out where the next solution will lie could be to just randomly sample the set of known solutions and pick the result of the random sampling. This does not guarantee accuracy, but it is very fast (fixed time) and the probability you are correct is high. When repeated in massive quantities you can simulate very complex things like fluid dynamics.</p>
<h3 id="las-vegas"><a class="header" href="#las-vegas">Las Vegas</a></h3>
<p>A Las Vegas algorithm is another randomized algorithm, but in contract to the Monte Carlo approach, it will always produce the correct result (or inform you of failure) at the cost of an uncertain runtime. It is generally applicable to problems where &quot;you'll know the solution when you see it.&quot; In essence, you randomly pick a possible solution, and if that solution is correct you return it, otherwise you repeat the process, failing after some threshold of attempts.</p>
<h3 id="hill-climbing"><a class="header" href="#hill-climbing">Hill Climbing</a></h3>
<p>Hill climbing algorithms apply to algorithms that have many solutions, and it is a strategy taken to find the <em>optimal</em> solution. For example, if you want to find the fastest path between two cities, you could find many paths, and optimize their speed over team via hill climbing.</p>
<p>The general premise is to arbitrarily pick a solution to start at, then make an incremental change to it. If the incremental change produces a better solution, then repeat the process. You can tune the algorithm in ways such as the amount of incremental changes that are attempted before giving up, or <em>how</em> incremental the changes actually are. In general, this will lead the optimal solution for problems with a convex (hill-shaped) solution set. However, for problems with multiple &quot;hills&quot;, you might only find the local optima.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinatorics"><a class="header" href="#combinatorics">Combinatorics</a></h1>
<h3 id="find-a-cycle-in-function-value-iterations-brents-algorithm"><a class="header" href="#find-a-cycle-in-function-value-iterations-brents-algorithm">Find a cycle in function value iterations (Brent's Algorithm)</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Brent%27s_method">Brent's Algorithm</a></p>
<h3 id="solve-the-stable-matching-problem-gale-shapley-algorithm"><a class="header" href="#solve-the-stable-matching-problem-gale-shapley-algorithm">Solve the stable matching problem (Gale-Shapley Algorithm)</a></h3>
<p>The stable matching problem is as follows: Given <em>n</em> students and <em>n</em> internships, and each participant has an ordering or ranking for which students/internships they would prefer, generate a stable matching for each participant. All matches are stable if there are no cases such that a student would prefer an internship they weren't matched with, <em>and</em> that intership would also prefer that student to the one they were matched with. Note that you can replace &quot;students&quot; and &quot;internships&quot; with any entities that need to be matched and have preferences.</p>
<p>The Gale-Shapley algorithm starts by trying to match each student with the internship they prefer most. Each intership with a match offer will then choose among the students that matched to them the one they most prefer, and reject the others. Then, each unmatched student will try to match with their 2nd-most preferred intership, and the interships will then repeat the process of choosing only the student they most prefer (if they prefer a student among their new offers to the one they currently are matched with--if they have a match--then they will take the new student). This process repeats until there are no unmatched students.</p>
<p>The runtime complexity of the algorithm is \( O(n^2) \).</p>
<h3 id="generate-a-pseudorandom-number-mersenne-twister-linear-congruential-generator-blum-blum-shub"><a class="header" href="#generate-a-pseudorandom-number-mersenne-twister-linear-congruential-generator-blum-blum-shub">Generate a pseudorandom number (Mersenne Twister, Linear Congruential Generator, Blum Blum Shub)</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister</a></p>
<p><a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Generator</a></p>
<p><a href="https://en.wikipedia.org/wiki/Blum_Blum_Shub">Blum Blum Shub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph--tree"><a class="header" href="#graph--tree">Graph &amp; Tree</a></h1>
<h3 id="find-the-lower-common-ancestor-in-a-tree-or-directed-acyclic-graph-tarjans-off-line-lowest-common-ancestors-algorithm"><a class="header" href="#find-the-lower-common-ancestor-in-a-tree-or-directed-acyclic-graph-tarjans-off-line-lowest-common-ancestors-algorithm">Find the lower common ancestor in a tree or directed acyclic graph (Tarjan's Off-Line Lowest Common Ancestors Algorithm)</a></h3>
<p>Recall that the lowest common ancestor of two nodes in a tree is the lowest node in the tree with those two nodes somewhere in its subtrees.</p>
<p>The basic premise is to follow a post-order traversal of the tree, keeping track of 
The simplified process of finding the lowest common ancestor of nodes <em>u</em> and <em>v</em> in a tree rooted at <em>root</em> is as follows:</p>
<pre><code>function getLcs(root, u, v)
    root.ancestor -&gt; root
    for each child in root.children // left-to-right order
        getLcs(child, u, v)
        child.ancestor -&gt; u.ancestor
    if root is u and v is visited
        return v.ancestor
    else if root is v and u is visited
        return u.ancestor
    root.isVisited = true
</code></pre>
<p>By pre-processing the tree into arrays, one where arr[i] is the visitation status of node <em>i</em> and one where arr[i] is the ancestor of node[i], you can reduce the time complexity of some operations.</p>
<p>A refined variation of this algorithm can perform in linear (\( O(n) \)) time.</p>
<h3 id="measure-the-importance-of-a-website-pagerank"><a class="header" href="#measure-the-importance-of-a-website-pagerank">Measure the importance of a website (PageRank)</a></h3>
<p>The PageRank algorithm was the original Google. The underyling assumption is that more important websites are likely to receive links from other websites, thus the PageRank algorithm works by performing a web crawl and counting the number and quality of links to pages to determine how important they are.</p>
<p>More info <a href="https://en.wikipedia.org/wiki/PageRank">here</a>.</p>
<h3 id="compute-the-maximum-flow-in-a-flow-network-or-directed-graph-ford-fulkerson-algorithm-edmonds-karp-algorithm"><a class="header" href="#compute-the-maximum-flow-in-a-flow-network-or-directed-graph-ford-fulkerson-algorithm-edmonds-karp-algorithm">Compute the maximum flow in a flow network or directed graph (Ford-Fulkerson Algorithm, Edmonds-Karp Algorithm)</a></h3>
<p>Recall that finding the maximum flow in a flow network entails finding which path through the flow network will allow you to end the path with the highest amount of flow possible.</p>
<p>For this problem there are two algorithms: Ford-Fulkerson and Edmonds-Karp. The difference being that the Ford-Fulkerson algorithm is more of a prescribed idea, whereas the Edmonds-Karp algorithm is actually a fully implemented and optimized version of the Ford-Fulkerson algorithm.</p>
<p>The inputs to the problem consist of a flow network (a graph), a flow capacity, a source node, and a sink node.</p>
<p>To solve the problem you start by assigning all edges a value of 0. Using a breadth-first search approach to traversing the graph, you can generate a list of possible paths to get to the sink node from the source node. In the process of &quot;searching&quot;, you are stopping when you find a path that reaches the sink node. At that point in time you will figure out the minimum capacity among the edges from the source to the sink in that path, and add that minumum value to the edges in that path. Your search then continues, but the key here is that, as you continue determining the minimum capacity of edges in a path, you use the <em>remaining</em> capacity of the edges, <em>not</em> the actual capacity. So if you have already assigned an edge a value of 3 and its capacity is 5, then its new capacity is 2 for all future calculations.</p>
<p>The time complexity of the Edmonds-Karp algorithm is \( O(VE^2) \), where <em>V</em> is the number of nodes, and <em>E</em> is the number of edges.</p>
<h3 id="find-the-minimum--cut-of-a-graph-kargers-algorithm"><a class="header" href="#find-the-minimum--cut-of-a-graph-kargers-algorithm">Find the minimum  cut of a graph (Karger's Algorithm)</a></h3>
<p>Recall that the minimum cut of a graph is a slice through the graph which intersects the least amount of edges in the graph.</p>
<p>Karger's algorithm picks a neighboring pair of vertices at random and contracts the edge connecting them (the two nodes are merged, and their edges are moved to the new node), then repeats the process on the newly created graph until there are only two vertices left. The determined cut is then the one which goes through the edges connecting the final two vertices. The algorithm follows the monte carlo formula at its core, and thus does not <em>guarantee</em> the correct answer, but has a high probably of finding the correct answer, especially if repeated a sufficient number of times.</p>
<p>As a monte carlo algorithm, the probability of success is more important than the runtime, as you will want to run it enough times to increase the probability of success to within whatever your personal threshold is. More info <a href="https://en.wikipedia.org/wiki/Karger%27s_algorithm#Analysis">here</a></p>
<h3 id="find-the-minimum-spanning-tree-of-an-undirected-edge-weighted-graph-kruskals-algorithm-prims-algorithm"><a class="header" href="#find-the-minimum-spanning-tree-of-an-undirected-edge-weighted-graph-kruskals-algorithm-prims-algorithm">Find the minimum spanning tree of an undirected, edge-weighted graph (Kruskal's Algorithm, Prim's Algorithm)</a></h3>
<p>The main difference between Kruskal's algorithm and Prim's algorithm is that Kruskal's will work on a disconnected graph (it can find the minimum spanning forest). Also, against a sufficiently dense graph, Prim's algorithm can be made to run in linear time.</p>
<p>Recall that a minimum spanning tree is a subset of the edges of a weighed, undirected graph that connects all the vertices together without containing any cycles and with the minimum weight possible.</p>
<p>Kruskal's algorithm starts by creating a list of forests consisting of one node from the graph (each node is its own forest). Then, the edges in the graph are sorted by weight. One-by-one, the lightest edge is remove from the graph. If that edge connects two forests, then it is added to the minimum spanning tree, and the two forests are joined into one forest. This process is repeated until all a spanning tree is established. This is essentially a modified greedy algorithm.</p>
<p>Kruskal's algorithm runs in \( O(E \log E) \) time.</p>
<p>Prim's algorithm is a more of a pure greedy algorithm. Starting from an arbitrary vertex in the graph, choose the minimum weighted edge connected to that vertex that does not connect to a vertex already covered by the spanning tree in progress.</p>
<p>Prim's algorithm [typically] runs in \( O(E + V \log V) \) time (though it depends on the data structure used to implement it).</p>
<h3 id="find-the-shortest-path-between-two-points-in-a-weighted-graph-with-only-non-negative-weights-dijkstras-algorithm"><a class="header" href="#find-the-shortest-path-between-two-points-in-a-weighted-graph-with-only-non-negative-weights-dijkstras-algorithm">Find the shortest path between two points in a weighted graph with only non-negative weights (Dijkstra's Algorithm)</a></h3>
<p>Dijsktra's algorithm is a classic algorithm for finding the shortest path between two points in a weight graph. The applications of the algorithm are plentiful. This algorithm is the fastest knwon for finding the shortest path in an arbitrary directed graph with unbounded and non-negative edge weights. However, for more specialized cases (bounded edge weights, integer-only edge weights, directed acyclic graphs, etc.), there also exist more specialized variants that can do them a little faster.</p>
<p>Dijsktra's algorithm is as follows: All nodes are marked as having a distance from the source node of infinity and are unvisited. The source node is then given a distance value of 0 (it is 0 distance from itself). Starting at the source node, all neighboring nodes are analyzed to determine what their distance from the source would be if the path goes through them: the neighboring nodes are given a tentative distance value equal to the current node's distance value plus the distance it is from the current node; If the tenative value is less than its current value then its current value is replaced with the tentative one. Once all neighbors are analyzed, the current node is set as visited. The process is then repeated with the node that currently has the lowest distance value that has not been visited. Once the target node is reached, the algorithm ends, and you simply walk backwards, choosing the nodes with the shortest assigned distance, until you are back at the source in order to determine the shortest path.</p>
<p>Dijkstra's algorithm runs in \( O(E + V \log V) \) time when implemented with a fibonacci heap, but the amortized runtime can be improved to \( O(E + V \log \frac E V \log V) \) using binary heaps.</p>
<h3 id="find-the-shortest-path-between-two-points-in-a-weighted-graph-bellman-ford-algorithm"><a class="header" href="#find-the-shortest-path-between-two-points-in-a-weighted-graph-bellman-ford-algorithm">Find the shortest path between two points in a weighted graph (Bellman-Ford Algorithm)</a></h3>
<p>The Bellman-Ford algorithm solves the same problem as Dijkstra's algorithm, except that it can accommodate negative edge weights. The caveat is that if there is a cycle in the graph that totals to a negative value from edge weights, then obviously the solution would involve indefinitely following that loop.</p>
<p>While Dijkstra's algorithm greedily selects the closest vertex that has not been visited after assigning distances, the Bellman-Ford algorithm simply repeats the process for <em>every</em> vertex, thus doing away with the need to denote vertices as &quot;visited&quot;. At the end of the process, the same walk backwards from the target is performed. The algorithm thus takes \( O(E \cdot V) \) time.</p>
<h3 id="solve-the-traveling-salesman-problem-nearest-neighbor-algorithm-brute-force-algorithm"><a class="header" href="#solve-the-traveling-salesman-problem-nearest-neighbor-algorithm-brute-force-algorithm">Solve the traveling salesman problem (Nearest Neighbor Algorithm, Brute Force Algorithm)</a></h3>
<p>The goal of the traveling salesman problem is to determine the fastest route a salesman can take that goes through all the different cities they want to visit and then returns to the starting city.</p>
<p>There are two approaches to this problem: The brute force approach and the nearest neighbor approach.</p>
<p>The nearest neighbor algorithm uses the greedy method to select the nearest city to the one you are currently at that has not already been visited. This is only an approximate solution.</p>
<p>The brute force algorithm simply calculates the distance of every possible path (stopping if the path goes longer than the current minimum).</p>
<p>This problem is used as a benchmark for many optimization methods, as it is computationally difficult and applicable to many real-world problems.</p>
<h3 id="solve-the-knights-tour-problem-warnsdorffs-rule"><a class="header" href="#solve-the-knights-tour-problem-warnsdorffs-rule">Solve the knight's tour problem (Warnsdorff's Rule)</a></h3>
<p>The knight's tour problem has the goal of determining what sequence of moves a knight can make on a chess board that brings it to every square exactly once, ending on the square it started on. It is an instance of the more general Hamiltonian path problem in graph theory (try to hit every vertex in a graph exactly once).</p>
<p>Warnsdorff's rule is heuristic that dictates one should choose to move the knight to the square from which it will have the fewest possible moves (in essence being a greedy method solution). In practice, not all Hamiltonian path problems can be solved in this way, but there are many special cases where the heuristic does apply, and thus it's not a bad idea to try applying this heuristic if you encounter such a problem.</p>
<h3 id="traverse-a-graph-in-search-of-a-specific-vertex-or-value-breadth-first-search-depth-first-search-best-first-search"><a class="header" href="#traverse-a-graph-in-search-of-a-specific-vertex-or-value-breadth-first-search-depth-first-search-best-first-search">Traverse a graph in search of a specific vertex or value (Breadth-First Search, Depth-First Search, Best-First Search)</a></h3>
<h4 id="breadth-first-search"><a class="header" href="#breadth-first-search">Breadth-First Search</a></h4>
<p>Check the starting node, then check each adjacent node to the start, then check each adjacent node to the adjacent nodes, and so on. In a tree, this amounts to searching an entire level before moving on to the next.</p>
<p>\( O(V + E) \) time and O(V) space.</p>
<h4 id="depth-first-search"><a class="header" href="#depth-first-search">Depth-First Search</a></h4>
<p>Check the starting node, then, for each adjacent node, repeat this process. In a tree this amounts to searching a lineage/branch before moving on to the next.</p>
<p>\( O(V + E) \) time and O(V) space.</p>
<h4 id="best-first-search"><a class="header" href="#best-first-search">Best-First Search</a></h4>
<p>Choose which node to explore next by some pre-determined rule. The runtime is thus not constant.</p>
<h3 id="traverse-a-tree-in-search-of-a-specific-node-or-value-breadth-first-search-depth-first-search-best-first-search-pre-order-traversal-in-order-traversal-post-order-traversal"><a class="header" href="#traverse-a-tree-in-search-of-a-specific-node-or-value-breadth-first-search-depth-first-search-best-first-search-pre-order-traversal-in-order-traversal-post-order-traversal">Traverse a tree in search of a specific node or value (Breadth-First Search, Depth-First Search, Best-First Search, Pre-Order Traversal, In-Order Traversal, Post-Order Traversal)</a></h3>
<p>Trees have the same standard traversal methods as graphs (because trees are, in effect, a specialized graph), but the starting node is always the root. Additionally, there are some common orderings when performing a depth-first search:</p>
<h4 id="pre-order-traversal"><a class="header" href="#pre-order-traversal">Pre-Order Traversal</a></h4>
<pre><code>function POT(root)
    nodes.add(root)
    POT(root.left)
    POT (root.right)
</code></pre>
<h4 id="in-order-traversal"><a class="header" href="#in-order-traversal">In-Order Traversal</a></h4>
<pre><code>function IOT(root)
    IOT(root.left)
    nodes.add(root)
    IOT(root.right)
</code></pre>
<h3 id="post-order-traversal"><a class="header" href="#post-order-traversal">Post-Order Traversal</a></h3>
<pre><code>function POT(root)
    POT(root.left)
    POT(root.right)
    nodes.add(root)
</code></pre>
<h3 id="find-the-largest-clique-in-a-graph-maxcliquemaxcliquedyn-algorithm"><a class="header" href="#find-the-largest-clique-in-a-graph-maxcliquemaxcliquedyn-algorithm">Find the largest clique in a graph (MaxClique/MaxCliqueDyn Algorithm)</a></h3>
<p>Recall that a clique is a subset of vertices in a graph which are all adjacent to each other (also called a complete subgraph). To find a max clique is to find a clique in a graph which contains the most nodes of any clique in the graph.</p>
<p>The MaxCliqueDyn algorithm is variation of MaxClique which can handle dynamically varying bounds on the clique size. More info <a href="https://en.wikipedia.org/wiki/MaxCliqueDyn_maximum_clique_algorithm">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence"><a class="header" href="#sequence">Sequence</a></h1>
<h3 id="find-the--kth--smallest-element-in-an-unordered-sequence-quickselect"><a class="header" href="#find-the--kth--smallest-element-in-an-unordered-sequence-quickselect">Find the \( k^{th} \) smallest element in an unordered sequence (Quickselect)</a></h3>
<p>Quickselect operates on bounds and a pivot, with the first bounds being the first and last indices of the sequence. A pivot is chosen at random from within the bounds, then the sequence is iterated through and moves elements smaller than the pivot to the front of the list. Once the sequence is iterated through, it is read from last-to-first until a value smaller than the pivot is found, at which point the pivot is placed there in the sequence (so now the pivot is in the correct position as if the sequence was sorted). Now, if the pivot is in position <em>k</em>, then it is returned. Otherwise, if the pivot is in a position greater than <em>k</em>, the process is repeated with the current pivot as the new right bound and the start of the sequence as the left bound; if the pivot is in a position less than <em>k</em>, the process is repeated with the current pivot as the new left bound and the end of the sequence as the right bound. In either non-<em>k</em> situation, a new pivot is chosen.</p>
<p>Quickselect runs in \( O(n) \) time on average, but \( O(n^2) \) time in the worst case. It is able to be implemented in-place (i.e. without needing to use an auxilliary data structure), and is used frequently in real-world applications.</p>
<h3 id="find-an-item-in-an-unordered-sequence-linearsequentialbrute-force-search"><a class="header" href="#find-an-item-in-an-unordered-sequence-linearsequentialbrute-force-search">Find an item in an unordered sequence (Linear/Sequential/Brute Force Search)</a></h3>
<p>A most basic of algorithms: if your item is not the first item, then check the next item and repeat. \( O(n) \) time. Included to illustrate brute forcing.</p>
<h3 id="randomly-shuffle-a-finite-set-fisher-yatesknuth-shuffle"><a class="header" href="#randomly-shuffle-a-finite-set-fisher-yatesknuth-shuffle">Randomly shuffle a finite set (Fisher-Yates/Knuth Shuffle)</a></h3>
<p>The Fisher-Yates shuffle (A.K.A. the Knuth shuffle) is an algorithm for generation a random permutation of a finite sequence. The basic idea is as follows:</p>
<pre><code>function shuffle(arr[n])
    for i = 0...n-2
        pick a random number j between i and n-1 (inclusive)
        swap arr[i] and arr[j]
</code></pre>
<p>Simple enough and \( O(n) \) time.</p>
<h3 id="find-the-sequence-alignment-between-two-strings-that-results-in-the-shortest-levenshtein-distance-using-whitespace-as-a-buffer-hirschbergs-algorithm-needleman-wunsch-algorithm"><a class="header" href="#find-the-sequence-alignment-between-two-strings-that-results-in-the-shortest-levenshtein-distance-using-whitespace-as-a-buffer-hirschbergs-algorithm-needleman-wunsch-algorithm">Find the sequence alignment between two strings that results in the shortest Levenshtein distance, using whitespace as a buffer (Hirschberg's Algorithm, Needleman-Wunsch Algorithm)</a></h3>
<p>Recall that the Levenshtein distance between two strings is the amount of single-character edits (insertion, deletion, or substitution) required to transform one string into the other.</p>
<p>Hirschberg's algorithm is a divide &amp; conquer twist on the classic dynamic programming model of the Needleman-Wunsch algorithm (which has a worse space requirement of \( O(nm) \)).</p>
<p>The Needleman-Wunsch algorithm is as follows:</p>
<pre><code>function getLevenshteinDistance(str1, str2)
    initialize dist[n][m]
    for i -&gt; 0...n
        for j -&gt; 0...m
            if i is 0
                dist[i][j] = 0
            else if j is 0
                dist[i][j] = 0
            else
                dist[i][j] = min(dist[i-1][j-1], dist[i-1][j], dist[i][j-1])
                if (str1[i] != str2[j])
                    dist[i][j] = dist[i][j] + 1
    return dist[n-1][m-1]
</code></pre>
<p>To get the steps required to transform one string into another, you can follow the path of minimum values (going vertically, horizontally, or diagonally) from <code>dist[n-1][m-1]</code> down to <code>dist[0][0]</code>. When the values of the strings in those positions are the same, no change is needed. When <em>i</em> and <em>j</em> are different then, if <em>i</em> is less than <em>j</em>, make an insertion between str1[i] and str1[i + 1], and if <em>i</em> is greater than <em>j</em>, make an insertion between str2[j] and str2[j + 1]. When the values are the same then a substitution is required.</p>
<p>The Hirschberg algorithm seeks to apply divide and conquer on the Needleman-Wunsch algorithm (finding the distance between the first half of the first string and first half of the second, and combining the with the results of the other halves, recursively) in order to save space. It takes \( O(nm) \) time and uses \( O(min(n,m)) \) space, where <em>n</em> is the length of the first string, and <em>m</em> is the length of the second.</p>
<h3 id="determine-whether-a-string-contains-another-given-string-boyer-moore-algorithm"><a class="header" href="#determine-whether-a-string-contains-another-given-string-boyer-moore-algorithm">Determine whether a string contains another given string (Boyer-Moore Algorithm)</a></h3>
<p>The traditional method of finding a substring within a string is as follows:</p>
<pre><code>function hasSubstring(str, substr)
    if (substr.length &gt; str.length)
        return false
    for (i = 0...m)
        if (str[i] != substr[i])
            return hasSubstring(str[1-&gt;n], substr);
    return true;
</code></pre>
<p>Which runs in \( O(nm) \) time.</p>
<p>The Boyer-Moore algorithm improves upon that by changing the recursive calls. The realization is that if you compare the substring to the string from back-to-front instead of from front to back then you can optimize the shift you make for the recursive call if the substring is not a match. The worst case runtime remains the same, but with the application of something known as the Galil rule, it can be reduced to linear time. More information about the Boyer-Moore algorithm is <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm">here</a>.</p>
<p>BONUS: A similar question is: does this string contain the characters of this other string in order?</p>
<p>The algorithm is as follows:</p>
<pre><code>function hasCharsInOrder(str, chars)
    if chars.length &gt; str.length
        return false
    else if str[0] == chars[0]
        return hasCharsInOrder(str[1-&gt;n], chars[1-&gt;m])
    else
        return hasCharsInOrder(str[1-&gt;n], chars)
</code></pre>
<p>It runs in \( O(n + m) \) time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting"><a class="header" href="#sorting">Sorting</a></h1>
<p>All the algorithms in this chapter accomplish the same goal by different means: sort the elements of a list.</p>
<h3 id="bubble-sort"><a class="header" href="#bubble-sort">Bubble Sort</a></h3>
<p>Bubble sort is a pretty rudimentary algorithm primarily used for educational purposes (which is what this guide is for, so it appears here). It's a very straightforward process. Go through the list; if the current element is greater than the next element then swap them, else continue. Repeat that process until the list is sorted. Even in the average case it still takes \( O(n^2) \) time.</p>
<h3 id="quicksort"><a class="header" href="#quicksort">Quicksort</a></h3>
<p>Quicksort is very common sorting algorithm in the real world. It is a divide and conquer algorithm that starts by selecting a pivot element from the list and then going through the list, categorizing all other elements as &quot;less than&quot;, &quot;equal to&quot;, or &quot;greater than&quot; the pivot element. The sub-arrays are then sorted recursively, and combined at the end:</p>
<pre><code>function quicksort(arr)
    pivot = random i in 0 -&gt; n-1
    left = new array
    center = new array
    right = new array
    for each element in arr
        if element &lt; pivot:
            left.add(element)
        else if element &gt; pivot:
            right.add(element)
        else:
            center.add(element)
    return quicksort(left) + center + quicksort(right)
</code></pre>
<p>Quicksort has an \( O(n^2) \) worst case, \( O(n) \) best case, and \( O(n \log n) \) average case. It also has to use \( O(\log n) \) auxilliary space.</p>
<h3 id="insertion-sort"><a class="header" href="#insertion-sort">Insertion Sort</a></h3>
<p>Insertion sort is compared to the way people usually sort a hand of playing cards.</p>
<p>The premise is to go through the list one-by-one and examine the element at that index. If it is less than the element to its left, then swap the two elements and repeat, otherwise (or if it is at position 0) stop and move on to repeat this process with the next element in the list.</p>
<pre><code>function insertionsort(arr)
    for i = 1...n-1
        val = arr[i]
        for j = i-1...0
            if arr[j] &gt; val
                arr[j+1] = arr[j]
            else
                arr[j+1] = val
                break
</code></pre>
<p>It has an \( O(n^2) \) runtime, although it is perhaps the best sorting algorithm for a list that is alread mostly sorted. It can also be performed in place.</p>
<h3 id="merge-sort"><a class="header" href="#merge-sort">Merge Sort</a></h3>
<p>Merge sort is one of the common real-world sorting algorithms. It is a divide and conquer algorithm, which starts by dividing the list in n sublists of one element each. A single-element list is, of course, sorted by default. From there, pair up each sublist with another and merge them together with the logic as follows:</p>
<pre><code>function merge(arr1, arr2)
    i = 0
    j = 0
    result = new arr
    while (i &lt; n || j &lt; n)
        if j == n || arr1[i] &lt;= arr2[j]
            result.add(arr1[i])
            i += 1
        else
            result.add(arr2[j])
            j += 1
    return result
</code></pre>
<p>The process of pairing up and merging sublists is repeated until there is only one list (the final, sorted list).</p>
<p>This takes \( O(n \log n) \) time in the worst case, and uses \( O(n) \) auxilliary space.</p>
<h3 id="timsort"><a class="header" href="#timsort">Timsort</a></h3>
<p>Timsort was originally developed for use in the python programming language. It is a stable algorithm, meaning if two equivalent (equal by comparison, but different, perhaps by reference), values are in the list, their relative ordering will be maintained in the final product.</p>
<p>It is heavily based on merge sort and insertion sort. More information <a href="https://en.wikipedia.org/wiki/Timsort">here</a>.</p>
<p>In the worst case it takes \( O(n \log n) \) time. It has an advantage over quicksort when sorting object references or pointers.</p>
<h3 id="bucket-sort"><a class="header" href="#bucket-sort">Bucket Sort</a></h3>
<p>Bucket sort works by creating <em>k</em> buckets representing a value or range of values. The list is then iterated through, placing the values in their relevant buckets, and then at the end the buckets are combined in order to create the sorted (or semi-sorted in the case that buckets represent ranges) list.</p>
<p>In most cases this is an inefficient sorting algorithm, taking at worst \( O(n^2) \) time, and on average \( O(n + \frac {n^2} k + k) \) time. In the case that <em>k</em> = <em>n</em> the runtime can be \( O(n) \), but the higher <em>k</em> is, the more space is used. The worst-case space complexity would be \( O(n \cdot k) \).</p>
<p>This algorithm is most useful when the length of the list exceeds the possible values. For instance, sorting a large amount of people by age.</p>
<h3 id="radix-sort"><a class="header" href="#radix-sort">Radix Sort</a></h3>
<p>Radix sort is a form of bucket sort that avoids comparisons by bucketing based on the radix of the list elements, starting either at the most significant digit or the least significant.</p>
<p>It runs in \( O(w \cdot n) \) time, and has equivalent space complexity, where <em>w</em> is the number of bits required to store the keys for the elements based on their radix. More info <a href="https://en.wikipedia.org/wiki/Radix_sort">here</a>.</p>
<h3 id="selection-sort"><a class="header" href="#selection-sort">Selection Sort</a></h3>
<p>Selection sort is an in-place sorting algorithm.</p>
<p>It is inefficient on large lists, and generally performs worse than both insertion sort and heapsort, but has advantages in its simplicity.</p>
<p>The general process is starting at index 0, find the smallest element and swap it with that index, then move to index 1 and repeat with the remaining unsorted elements.</p>
<p>It runs in \( O(n^2) \) time.</p>
<h3 id="heapsort"><a class="header" href="#heapsort">Heapsort</a></h3>
<p>Heapsort is an improvement upon selection sort. In the step where selection sort finds the smallest element, heapsort keeps the remaining (unsorted) elements in a heap so as to make the process of finding the minimum unsorted value much faster. The worst case scenario is improved to \( O(n \log n) \). Because it uses an array implementation of a heap on the remaining unsorted sequence, it only needs to use a constant of auxilliary space.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other"><a class="header" href="#other">Other</a></h1>
<h3 id="find-the-product-of-two-square-matrices-strassen-algorithm"><a class="header" href="#find-the-product-of-two-square-matrices-strassen-algorithm">Find the product of two square matrices (Strassen Algorithm)</a></h3>
<p>The Strassen Algorithm for matrix multiplication is not the fastest known algorithm, but most faster algorithms are very complex and derived from the Strassen one, so it's worth knowing nonetheless.</p>
<p>The standard way of multiplying two 4x4 matrices, A and B (\( A_{1,2} \) corresponds to matrix A, row 1, column 2), is as follows:</p>
<ul>
<li>\( C_{1,1} = A_{1,1}B_{1,1} + A_{1,2}B_{2,1} \)</li>
<li>\( C_{1,2} = A_{1,1}B_{1,2} + A_{1,2}B_{2,2} \)</li>
<li>\( C_{2,1} = A_{2,1}B_{1,1} + A_{2,2}B_{2,1} \)</li>
<li>\( C_{2,2} = A_{2,1}B_{1,2} + A_{2,2}B_{2,2} \)</li>
</ul>
<p>This method requires 8 multiplications. The Strassen algorithm takes advantage of the fact that there are shared multiplications among the 8, and it can be narrowed down to 7:</p>
<ul>
<li>\( M_1 = (A_{1,1} + A_{2,2})(B_{1,1} + B_{2,2}) \)</li>
<li>\( M_1 = (A_{2,1} + A_{2,2})B_{1,1} \)</li>
<li>\( M_1 = A_{1,1}(B_{1,2} - B_{2,2}) \)</li>
<li>\( M_1 = A_{2,2}(B_{2,1} - B_{1,1}) \)</li>
<li>\( M_1 = (A_{1,1} + A_{1,2})B_{2,2} \)</li>
<li>\( M_1 = (A_{2,1} - A_{1,1})(B_{1,1} + B_{1,2}) \)</li>
<li>\( M_1 = (A_{1,2} - A_{2,2})(B_{2,1} + B_{2,2}) \)</li>
</ul>
<p>Which are used as follows:</p>
<ul>
<li>\( C_{1,1} = M_1 + M_4 - M_5 + M_7 \)</li>
<li>\( C_{1,2} = M_3 + M_5 \)</li>
<li>\( C_{2,1} = M_2 + M_4 \)</li>
<li>\( C_{2,2} = M_1 - M_2 + M_3 + M_6 \)</li>
</ul>
<p>To calculate the product of 2 matrices of size NxN where N 2 1, the Strassen algorithm divides each matrix into a 2x2 matrix of submatrices. In the case of odd N, there may be some 1x1 submatrices. The submatrices are multiplied recursively and so on until the result of the base matrix is produced.</p>
<p>It excels in multiplying matrices where \( N = 2^i \) for some integer <em>i</em>. It runs in \( O(N^{2.8074...}) \) time, but that's probably not worth memorizing.</p>
<h3 id="apply-a-fourier-transform-cooley-turkey-algorithm-fast-fourier-transform"><a class="header" href="#apply-a-fourier-transform-cooley-turkey-algorithm-fast-fourier-transform">Apply a Fourier Transform (Cooley-Turkey Algorithm, Fast Fourier Transform)</a></h3>
<p>A Fourier transform has many uses in the real world, but it is a complex thing. The Fast Fourier Transform is an optimal way to derive a Fourier transform, and the Cooley-Turkey algorithm is an algorithm that uses that method. More info <a href="https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm">here</a>.</p>
<h3 id="given-the-feedback-history-of-a-function-a-current-value-and-a-desired-value-determine-what-new-value-applied-to-the-function-will-likely-yield-the-desired-value-pid-controller"><a class="header" href="#given-the-feedback-history-of-a-function-a-current-value-and-a-desired-value-determine-what-new-value-applied-to-the-function-will-likely-yield-the-desired-value-pid-controller">Given the feedback history of a function, a current value, and a desired value, determine what new value applied to the function will likely yield the desired value (PID Controller)</a></h3>
<p>As the section title suggests, PID controllers estimate what input to a function will yield the desired output based on the history of the function's inputs and outputs, and which state the context is in.</p>
<p>Another complex operation involving math principles. More info <a href="https://en.wikipedia.org/wiki/PID_controller">here</a>.</p>
<h3 id="factor-an-integer-general-number-field-sieve"><a class="header" href="#factor-an-integer-general-number-field-sieve">Factor an integer (General Number Field Sieve)</a></h3>
<p>The General Number Field Sieve is a classical way of factoring integers. Another complex operation involving math principles. More info <a href="https://en.wikipedia.org/wiki/General_number_field_sieve">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-stores"><a class="header" href="#data-stores">Data Stores</a></h1>
<h2 id="cap-theorem"><a class="header" href="#cap-theorem">CAP Theorem</a></h2>
<p>It is impossible for a distributed data store to guarantee more than 2 of the following:</p>
<ul>
<li>Consistency: Every read gets the most recent write (or an error).</li>
<li>Availability: Every request receives a non-error response.</li>
<li>Partition Tolerance: The system will function regardless of time delay or dropped messages.</li>
</ul>
<p>It is implied that a data store with network partitioning will therefore have to choose between consistency and availability.</p>
<h2 id="acid-transactions"><a class="header" href="#acid-transactions">ACID Transactions</a></h2>
<p>An ACID transaction is one which satisfies the following 4 characteristics:</p>
<ul>
<li>Atomicity: Each transaction, regardless of how complex, will either completely succeed or completely fail, so there are no partial updates to the data store.</li>
<li>Consistency: Transactions can only bring the database from one valid state to another.</li>
<li>Isolation: Transactions processed concurrently are guaranteed to have the same end result as if they were processed sequentially.</li>
<li>Durability: Once a transaction has been committed it will remain committed, regardless of system availability (i.e. data is stored in non-volatile memory).</li>
</ul>
<p>Note the difference between the &quot;consistency&quot; of an acid transaction and &quot;consistency&quot; in the CAP theorem.</p>
<h2 id="base-models"><a class="header" href="#base-models">BASE Models</a></h2>
<p>A data store that follows the BASE model is one which satisfies the following 3 characteristics:</p>
<ul>
<li>Basic Availability: The data store stays available and able to process transactions, even if some nodes/clusters/partitions have failed.</li>
<li>Soft State: Consistency of data is delegated to developers instead of being handled by the database.</li>
<li>Eventual Consistency: At some point, data will converge to a consistent state.</li>
</ul>
<p>The &quot;eventual consistency&quot; clause need only be proven theoretically.</p>
<h2 id="joins"><a class="header" href="#joins">Joins</a></h2>
<p>Traditionally, a join is an operation that combines data from two tables in a relational database management system. In practice though, many NoSQL environments can accommodate joins in some form, even if it is not built-in functionality.</p>
<h3 id="inner-join"><a class="header" href="#inner-join">Inner Join</a></h3>
<p><strong>Common Syntax</strong>: <code>SELECT Employee.Name, Department.Name FROM Employees AS Employee INNER JOIN Departments AS Department ON Employee.DepartmentId = Department.DepartmentId</code>
<strong>Effect</strong>: Combines rows in the Employees table with rows in the Departments table that have the same DepartmentId, ignoring nulls and rows with no match.</p>
<h3 id="left-outer-join"><a class="header" href="#left-outer-join">Left Outer Join</a></h3>
<p><strong>Common Syntax</strong>: <code>SELECT Employee.Name, Department.Name FROM Employees AS Employee LEFT OUTER JOIN Departments AS Department ON Employee.DepartmentId = Department.DepartmentId</code>
<strong>Effect</strong>: Combines rows in the Employees table with rows in the Departments table that have the same DepartmentId. It will keep all rows in the Employees table, and if there is no matching row in the Departments table it will use null for the Department values (Department.Name in this case). It will still ignore nulls and rows with no match from the Departments table.</p>
<h3 id="right-outer-join"><a class="header" href="#right-outer-join">Right Outer Join</a></h3>
<p><strong>Common Syntax</strong>: <code>SELECT Employee.Name, Department.Name FROM Employees AS Employee RIGHT OUTER JOIN Departments AS Department ON Employee.DepartmentId = Department.DepartmentId</code>
<strong>Effect</strong>: Combines rows in the Departments table with rows in the Employees table that have the same DepartmentId. It will keep all rows in the Departments table, and if there is no matching row in the Employees table it will use null for the Employee values (Employee.Name in this case). It will still ignore nulls and rows with no match from the Employees table. This is not a common join since it is equivalent to a Left Outer Join where the FROM and JOIN tables are swapped.</p>
<h3 id="full-outer-join"><a class="header" href="#full-outer-join">Full Outer Join</a></h3>
<p><strong>Common Syntax</strong>: <code>SELECT Employee.Name, Department.Name FROM Employees AS Employee FULL OUTER JOIN Departments AS Department ON Employee.DepartmentId = Department.DepartmentId</code>
<strong>Effect</strong>: Produces the union of a Left Outer Join and a Right Outer Join (all rows from both tables will be accounted for, and nulls will be inserted where matches weren't found).</p>
<h3 id="cross-join-aka-cartesian-join"><a class="header" href="#cross-join-aka-cartesian-join">Cross Join (A.K.A. Cartesian Join)</a></h3>
<p><strong>Common Syntax</strong>: <code>SELECT Employee.Name, Department.Name FROM Employees AS Employee CROSS JOIN Departments AS Department</code>
<strong>Effect</strong>: Produces the cartesian product of the two tables. A new row will be created for every combination of rows between the two tables.</p>
<h2 id="deciding-what-to-use"><a class="header" href="#deciding-what-to-use">Deciding What To Use</a></h2>
<p>So the lingering question is, &quot;When do I use NoSQL, and when do I use SQL?&quot; Well, in general, NoSQL is simply more flexible, and can be used in pretty much any situation. Most of the benefits of SQL are things that can be emulated for NoSQL within the calling code, but that does add complexity. Additionally, in the modern development environment, you can use different databases for different tasks, so keep that in mind.</p>
<p>Here are some things to look for that might indicate SQL being better for your use case:</p>
<ul>
<li>You need to accommodate a wide array of complex queries that combine results across different subdomains in your application (e.g. for generating reports).</li>
<li>You need to ensure ACID compliance (e.g. for financial applications).</li>
<li>You don't anticipate a lot of changes or growth.</li>
</ul>
<p>You might instead look into using NoSQL in the following cases:</p>
<ul>
<li>You have budget restrictions (SQL is more expensive to scale).</li>
<li>The data structures being managed are volatile/variable.</li>
<li>You plan to analyze large amounts of data, but don't need to manipulate/write data in such quantities.</li>
</ul>
<p>Other, more specific use cases for NoSQL include:</p>
<ul>
<li>Event capture and processing.</li>
<li>Storing data for intelligence engines to use.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relational-databases"><a class="header" href="#relational-databases">Relational Databases</a></h1>
<p>Relational data stores are the ones most people are comfortable with. They can be categorized by the following:</p>
<ul>
<li>Data is stored as relationships, in tabular form, usually representing an entity type.</li>
<li>Robust support for joins.</li>
<li>Requirement of ACID transactions.</li>
<li>Out-of-the-box support for relational algebra (including aforementioned joins).</li>
</ul>
<p>A core aspect of designing relational databases is the normalization of data. That is: The process of structuring a relational database to reduce redundancies in the data and improve data integrity. Normalization is an incremental process, and the varying degrees of normalization are as follows:</p>
<ol>
<li>1NF (First Normal Form): Each column of a table must be atomic (contain non-separable values, such as strings, integers, and dates, but not lists). To achieve this, you can usually split the non-atomic columns into their own tables and use a key to relate them to the original table.</li>
<li>2NF (Second Normal Form): Each non-key attribute (column) must be dependent on the whole table key (not just part of it). To achieve this, you can usually move a part of the key and its dependencies to a new table.</li>
<li>3NF (Third Normal Form): Non-key attributes in the table are exclusively dependent on the key. In other words: No non-key attribute should depend on another non-key attribute. This can usually be achieved by moving the non-key attribute in question to a new table where its dependency is a key.</li>
<li>BCNF (Boyce-Codd Normal Form): Each attribute represents a fact about &quot;the key, the whole key, and nothing but the key&quot;. This is often fixed by moving the attribute in question to a new table with only the parts of the original table's key that it cares about. This is an intermediary step between 3NF and 4NF but came about after 4NF, which is why it itself is not 4NF.</li>
<li>4NF (Fourth Normal Form): Every multi-value dependency (2+ values) is either trivial (every {x, y, ...} combination is unique in the table for that relationship) or the independent key in the dependency is a candidate key (only exists once in the table). This is best demonstrated with an example: Suppose you have a table with a key {Restaurant Name, Pizza Type, Delivery Area}. In this example pizza type and delivery area both depend on the restaurant, but do not depend on each other, so it can be split into two tables, one with a {Restaurant Name, Delivery Area} key, and one with a {Restaurant Name, Pizza Type} key.</li>
<li>5NF (Fifth Normal Form): Every non-trivial join relationship is implied by the keys in the table. You can verify 5NF by trying to split a table into new tables and then joining the split tables together. If there is no way to split the original table in a way that the new tables can be joined together to look identical to the original table, then that table satisfies 5NF.</li>
</ol>
<p>There are actually other normal forms, but they are more nuanced and not as frequently followed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nosql"><a class="header" href="#nosql">NoSQL</a></h1>
<p>NoSQL databases are exactly what their title claims they are: non-SQL databases. The hallmarks of a NoSQL database are as follows:</p>
<ul>
<li>Data storage is flexible by virtue of not being tied to relationships.</li>
<li>Adherance to the BASE model.</li>
<li>Efficient implementations of partitioning, clustering, etc. for distribution of data.</li>
</ul>
<p>Unlike relational systems, which are commonly designed around the entities and normalization of data (relationships are handled later via joins), NoSQL databases are commonly designed with runtime queries in mind. Stores might be created specifically for one query, and there may be redundancies across stores for that reason. Often, redundancies can be avoided, but sometimes they can't be in the name of performance.</p>
<p>There are many NoSQL data stores to choose from, but the most common ones fall under one of these categories:</p>
<ul>
<li>Key-Value: These act like dictionaries; They tie a key to a value. These are good for straight-forward lookups.</li>
<li>Document: Document stores are a dubclass of Key-Value stores wherein all the data is contained in a document, which could have any structure desired (similar to objects in programming). Documents in a database usually do not need to have matching schema. The data in key-value stores are inherently opaque to the database, whereas a document store relies on the internal structure of the document to extract metadata that the database engine can use to optimize transactions. This difference is usually moot.</li>
<li>Columnar: Columnar data stores store data in columns instead of rows. Traditional, row-based storage will serialize complete records together (e.g. for a &quot;Person&quot; with a &quot;Name&quot; and &quot;Age&quot;, you might see <code>John Smith, 30</code> and <code>Daisy Hopkins, 29</code> as the rows), whereas a columnar storage will serialize complete columns together (for the previous example: <code>Record 1: John Smith, Record 2: Daisy Hopkins</code> and <code>Record 1: 30, Record 2: 29</code>). The traditional, row-based storage lends itself to drawing relationships between tables, but for simple queries, the columnar store will be much more performant.</li>
<li>Graph: Graphs store data...in a graph! This adds a layer of relationships to objects in the store, making it useful for storing information about networks and groups, as well as lending itself to pathfinding queries.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-patterns"><a class="header" href="#design-patterns">Design Patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creational"><a class="header" href="#creational">Creational</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structural"><a class="header" href="#structural">Structural</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavioral"><a class="header" href="#behavioral">Behavioral</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional"><a class="header" href="#functional">Functional</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architectural"><a class="header" href="#architectural">Architectural</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloud-distributed"><a class="header" href="#cloud-distributed">Cloud Distributed</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-1"><a class="header" href="#other-1">Other</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-Patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interview-prep"><a class="header" href="#interview-prep">Interview Prep</a></h1>
<p>In addition to the questions covered in this chapter, which can generally be studied via flash cards and practice, here are some general interviewing tips:</p>
<ul>
<li>Update your personal website (don't have one? make one)</li>
<li>Update any professional social media profiles (e.g. LinkedIn)</li>
<li>Update your resume (create a copy specifically for the position/company you're applying to) and CV</li>
<li>Research the company</li>
<li>Write a cover letter and send it either with your resume or after you submit your resume (you can look up what to write, there are many examples online)</li>
<li>If the interview is planned more than a week in advance, it may be a good idea to write a confirmation letter to the interviewer a day or two before the interview. For example:
&gt;I'm writing to confirm our meeting for Thursday at 9:30 AM. I look forward to discussing my application for the software engineering position at [Company Name]. Please contact me if you have any last-minute questions or comments.</li>
<li>Bring a clean notepad and pen, copies of your resume, a list of references (if not included on resume), ID and Social Security card (in case you're asked to complete an application on the spot)</li>
<li>Write down the name of your interviewer(s) and the position and company you are interviewing for beforehand if you think you might forget any of those</li>
<li>Turn off your phone for the interview</li>
<li>Write a followup letter after the interview (next day) (you can look up what to write, there are many examples online)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="personalanecdotal-questions"><a class="header" href="#personalanecdotal-questions">Personal/Anecdotal Questions</a></h1>
<p>Your goal when answering any of these questions is basically to talk about how amazing you are without sounding bragadocious.</p>
<p>In addition to the below, common questions, anything on your resume is fair game; if you talked about specific projects on your resume, you should be prepared to answer questions about them.</p>
<h3 id="why-are-you-interested-in-this-position"><a class="header" href="#why-are-you-interested-in-this-position">Why are you interested in this position?</a></h3>
<p>Talk about you, and mention how passionate/enthusiastic you are about this position.</p>
<h3 id="what-makes-you-a-good-fit-for-this-position"><a class="header" href="#what-makes-you-a-good-fit-for-this-position">What makes you a good fit for this position?</a></h3>
<p>If possible, connect your skills directly to a problem the company has, and describe how you can solve it.</p>
<h3 id="what-are-your-greatest-strengths"><a class="header" href="#what-are-your-greatest-strengths">What are your greatest strengths?</a></h3>
<p>Brag about yourself, but make it relevant to the position.</p>
<h3 id="what-are-your-greatest-weaknesses"><a class="header" href="#what-are-your-greatest-weaknesses">What are your greatest weaknesses?</a></h3>
<p>Your &quot;weaknesses&quot; should actually be strengths, but phrased like something you want to improve upon.</p>
<p>Sometimes I like to include a bit about how I've improved myself based on peer/supervisor feedback to demonstrate a drive to improve. Doing so requires a bit more honesty, since you probably wont get feedback about &quot;weaknesses that aren't really weaknesses&quot; from your coworkers, so I don't do this with managerial interviewers, but I might throw it in when I'm interviewing with people that would be peers if I got the job. Also, you might specifically get a question about what kind of criticism you've had from coworkers, in which case it's probably best to be honest but choose the least bad piece of criticism you've received.</p>
<h3 id="how-would-you-handle-a-dispute-with-a-co-worker"><a class="header" href="#how-would-you-handle-a-dispute-with-a-co-worker">How would you handle a dispute with a co-worker?</a></h3>
<p>Generic answer: compromise.</p>
<h3 id="think-of-a-project-you-worked-on"><a class="header" href="#think-of-a-project-you-worked-on">Think of a project you worked on...</a></h3>
<ul>
<li><strong>What about the project was challenging? / What challenges did you face on the project?</strong></li>
<li><strong>What was an obstacle that you faced while working on the project, and how did you overcome it?</strong></li>
<li><strong>What did you learn from the project?</strong></li>
</ul>
<p>Pick a story where you're the hero if possible. If you aren't specifically asked to talk about how the project helped you grow, you should still talk about it anyways.</p>
<h3 id="what-made-you-want-to-leave-your-previouscurrent-job"><a class="header" href="#what-made-you-want-to-leave-your-previouscurrent-job">What made you want to leave your previous/current job?</a></h3>
<p>Whatever the real reason is, just say you're looking for &quot;greener pastures&quot; (i.e. a place to grow and expand your horizons). If you were to trash talk your old office it would make you look like a gossiper, and while there are other inoffensive and legitimate reasons to want to leave a job, none will likely sound as good as saying you want to grow as a professional and that you couldn't continue to do so at your old/current job.</p>
<h3 id="what-would-you-changeimprove-about-your-previouscurrent-job"><a class="header" href="#what-would-you-changeimprove-about-your-previouscurrent-job">What would you change/improve about your previous/current job?</a></h3>
<p>This is a hard question to prepare for. You don't want to trash talk your old workplace for the reasons mentioned above, or lie about a weakness in your old company that doesn't exist, and you also don't want to propose a change that highlights a potential weakness in the company you're applying to. A good example would be upward movement: many small companies don't have programs to elevate your position, whereas larger companies do, so if you're leaving a small company and applying to a big one you could say that. Long story short: bring up an honest disadvantage of your previous job, and mention a way to improve it that is already implemented at the company you're applying to.</p>
<h3 id="do-you-think-gpa-an-accurate-representation-of-work-ethic"><a class="header" href="#do-you-think-gpa-an-accurate-representation-of-work-ethic">Do you think GPA an accurate representation of work ethic?</a></h3>
<p>Don't take a side, even if your GPA is awesome or garbage. Say that the two might be/probably are correlated, but a good GPA doesn't necessarily indicate a good work ethic.</p>
<h3 id="whats-your-opinion-of-politicalreligious-topic"><a class="header" href="#whats-your-opinion-of-politicalreligious-topic">What's your opinion of [political/religious topic]</a></h3>
<p>Regardless of your opinion, lie if necessary and take a middle road stance. Questions about politics and religion have no place in an interview, and is even illegal in many places. You may be within your rights to sue the company if you don't get the job since and it seems like it could have been a result of this question. Even if you get the job, the kind of place that asks this question probably isn't the kind you should be working for.</p>
<h3 id="what-are-your-hobbies-outside-of-work"><a class="header" href="#what-are-your-hobbies-outside-of-work">What are your hobbies outside of work?</a></h3>
<p>Be honest, but pick your most attractive hobbies from a professional's perspective. Playing video games isn't really an attractive hobby. Any hobby in which you make something (whether it's coding or not) would be good to include on your list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="occupational-questions"><a class="header" href="#occupational-questions">Occupational Questions</a></h1>
<p>These are question that will test your knowledge of the trade and your problem solving skills.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="short-answer"><a class="header" href="#short-answer">Short Answer</a></h1>
<p>Note: In addition to what is provided here, you may be asked questions about anything you have put on your resume (e.g. How does X work in the Y programming language?).</p>
<p><strong>Q:</strong> What is \( 2^x \)? Note: \( x \) will rarely be more than 12.</p>
<details>
<summary>Answer</summary>
2, 4, 8, 16, 32, 64, etc.
</details>
<br>
<p><strong>Q:</strong> What is the difference between a struct and a class, and what might you use a struct for? Note: This is somewhat language-dependent (not all languages even have both).</p>
<details>
<summary>Answer</summary>
Structs usually give their properties and methods public modifiers by default, and in some modern languages they represent value types as opposed to reference types. Usually structs are used for simple objects or types, which don't need complex methods. In general, a struct might be appropriate when the data type is going to be small, and either it is expected to be short-lived or it is expected to be frequently embedded in other objects.
</details>
<br>
<p><strong>Q:</strong> What is a static class/method/variable?</p>
<details>
<summary>Answer</summary>
<ul>
<li>Class: A static class is one which cannot be instantiated.</li>
<li>Method: A static method is one which is not tied to an instance of an object.</li>
<li>Variable: A static variable is one which is shared across instances of an object.</li>
</ul>
</details>
<br>
<p><strong>Q:</strong> What do the 'public', 'protected', 'private', and 'internal' keywords denote?</p>
<details>
<summary>Answer</summary> 
These keywords refer to the accessibility of their subjects:
<ul>
<li>Public: Anyone can access this from anywhere.</li>
<li>Protected: When present in languages, it usually means only child classes can access this, and they can do so from anywhere.</li>
<li>Private: Only this object can access this.</li>
<li>Internal: When present in languages, it usually means anyone can access this, but only from within this package/library.</li>
</ul>
</details>
<br>
<p><strong>Q:</strong> What does being immutable entail, and what keywords can modify mutability?</p>
<details>
<summary>Answer</summary>
If something is immutable then it cannot be changed.
<ul>
<li>The 'const' keyword can make its subject immutable at compile time (in addition to being static).</li>
<li>The 'readonly', when present in a language, can make its subject immutable at run time. Its value can still only be set once, and usually only in the constructor of a class.</li>
</ul>
</details>
<br>
<p><strong>Q:</strong> What does the 'final' keyword denote?</p>
<details>
<summary>Answer</summary>
When present in a language, it prevents a class or method from being inherited or overriden, respectively.
</details>
<br>
<p><strong>Q:</strong> What is idempotence?</p>
<details>
<summary>Answer</summary>
A function is said to be idempotent if repeated function calls with the same input will only change the state of the state of the application once.
<ul>
<li>For example: getting a value and setting a value are idempotent, the end result is always the same after the first call is made, regardless of repetition. However, adding to a list is not idempotent, because repeated calls to add will keep modifying the list further.</li>
<li>In mathematical terms, a function \\( f \\) is idempotent if \\( f o f = f \\).</li>
</ul>
</details>
<br>
<p><strong>Q:</strong> What is lazy bind/loading?</p>
<details>
<summary>Answer</summary>
Waiting until a resource is needed before you bind/load it.
</details>
<br>
<p><strong>Q:</strong> What is reflection?</p>
<details>
<summary>Answer</summary>
Code's ability to inspect itself or other code in the same program.
</details>
<br>
<p><strong>Q:</strong> What are the 4 pillars of object-oriented design?</p>
<details>
<summary>Answer</summary>
<ul>
<li>Abstraction: The process of showing only the necessary features of an object to other code.</li>
<li>Inheritance: The ability to make a hierarchy of classes wherein child classes acquire certain properties and behaviors of parent classes.</li>
<li>Polymorphism: The ability of a child class to both share and extend the properties and behavior of a parent class.</li>
<li>Encapsulation: The process of wrapping properties and behavior in an object so that access to each property and function can be controlled, and so that properties and behavior can be related to each other.</li>
</ul>
</details>
<br>
<p><strong>Q:</strong> What's the difference between inheriting and interfacing?</p>
<details>
<summary>Answer</summary>
Inheritance defines what an object is, whereas interfacing defines what an object can do.
</details>
<br>
<p><strong>Q:</strong> What is a pure function?</p>
<details>
<summary>Answer</summary>
A function with no side-effects that always returns the same output for a given input.
</details>
<br>
<p><strong>Q:</strong> What is NP-Completeness?</p>
<details>
<summary>Answer</summary>
A problem is said to be NP if it has a non-deterministic polynomial-time solution, and a problem is said to be NP-Hard if every NP problem can be transformed into it in polynomial time. For a problem to be NP-Complete means that it is both NP and NP-Hard.
</details>
<br>
<p><strong>Q:</strong> What is a lock/mutex?</p>
<details>
<summary>Answer</summary>
A mechanism for controlling access to a resource. Unlike semaphores, only one task can gain access to a lock/mutex at a time in order to access the resource.
</details>
<br>
<p><strong>Q:</strong> What is a semaphore?</p>
<details>
<summary>Answer</summary>
A variable used to signal the availability of a resource. Unlike locks/mutexes, a semaphore can allow multiple tasks to access a resource; a semaphore value of 0 indicates that no other tasks are allowed access to the resource, and a value of more than 0 allows that many more tasks to access the resource. Consequently, a binary semaphore (a semaphore only allowed to be 0 or 1) can be used to implement a lock/mutex.
</details>
<br>
<p><strong>Q:</strong> Explain Agile software development.</p>
<details>
<summary>Answer</summary>
Agile software development is a practice that promotes self-organization and cross-functionality within teams. It puts an emphasis on continual improvement and constant interactions with end users to be able to adjust the product as needed.
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="whiteboard"><a class="header" href="#whiteboard">Whiteboard</a></h1>
<p>Competitive tech companies are notorious for giving computer science applicants a barrage of whiteboard problems. The thing that distinguishes these problems from other common interview problems is their long form and focus on critical thinking, as opposed to rote memorization. These come in the form of &quot;here's what you know, here's what you want to know, write an algorithm to find out what you want to know.&quot; You probably wont be given a computer, you probably wont be allowed to use your phone, and you probably wont be given a piece of paper; It's just you and a whiteboard.</p>
<p>Even if you're well-acquainted with the algorithms chapter you may still find these problems difficult, but there are some steps you can take alleviate the challenge and impress the interviewer:</p>
<ul>
<li>Know the inputs, outputs, requirements, and constraints. 
<ul>
<li>Ask the interviewer about these if you are unsure.</li>
<li>Usually you aren't given the method signature of the solution. Instead, the question might be simply, &quot;Given a list of people, sort them by age&quot;. Here, you can ask questions like, &quot;What should a person object look like?&quot; (they might just have you create it to see what you come up with). Such questions can apply to outputs as well. Even better, you could ask, &quot;Can I assume that the maximum age of a person is 150?&quot; That question could be the difference between implementing quick sort and implementing bucket sort.</li>
<li>Common requirements and constraints might revolve around runtime, complexity, memory usage, etc. It's likely that you wont receive such requirements/constraints if they are not mentioned by the interviewer. However, if you solve the problem quickly, they may try to expand upon the question by asking you to solve it under certain constraints or with certain requirements.</li>
</ul>
</li>
<li>Think out loud. Interviewers want to hear your thought process, and sometimes they might correct your course if they can tell you're going down the wrong path.</li>
<li>Don't try to write syntactically correct programs (unless asked). Write pseudo-code. It's faster, and you reduce the risk of syntactical errors ruining your solution.</li>
<li>If you can't think of a solution immediately, then start by trying to recall any algorithms that might solve the problem with a little transformation. A well-known example of this is the bipartite matching problem, which can be transformed into a maximum flow problem, which has a known algorithmic solution.</li>
<li>If you can't recall an algorithm that matches this problem, then pick a top-level algorithm and design a new algorithm yourself (refresher: top-level algorithms include brute force, divide &amp; conquer, greedy method, and dynamic programming).</li>
<li>Don't forget about recursion. Interviewers seem to love recursion. If you can solve a problem in a simple way with recursion, do it!</li>
<li>Address all possible inputs. Usually edge cases can be solved with simple <code>if</code> statements, so it can be beneficial to address them last if time is a concern.
<ul>
<li>Remember: negatives, zeros, positives, minimums, maximums. Aside from those, it's situational (e.g. if using division with a variable denominator, you need to check that the denominator can never be 0).</li>
</ul>
</li>
<li>If you solve a problem quickly, and you notice that there are places in the solution that an exception could be thrown if it were converted to real code on a machine, then you might sound smarter if you ask if you should handle possible exceptions. This is rarely encountered, and rarely a requirement, just something to keep in mind if you breezed through the problem.</li>
</ul>
<p>NOTE: Problems covered in the algorithms chapter and in the general knowledge chapter are not included (e.g. Traveling Salesman, Levenshtein Distance, Value Swap).</p>
<h3 id="activity-selection"><a class="header" href="#activity-selection">Activity Selection</a></h3>
<p>Given <em>n</em> activities and their start/end times, determine the maximum number of activities (and which activities those are) that a single person can participate in, assuming they cannot do multiple activities at once.</p>
<p>A variation of this would be to not maximize the number of activities, but rather minimize the time in which you are not participating in an activity.</p>
<h3 id="huffman-encoding-tree"><a class="header" href="#huffman-encoding-tree">Huffman Encoding Tree</a></h3>
<p>A Huffman code is a type of prefix code used for lossless compression.</p>
<p>Given a set of symbols and their weights, find a set of codewords with minimum expected length (a tree with minimum weighted path length from the root).</p>
<p>Basically, you want to create a tree where each leaf node is one of the symbols given. This is most easily made as a binary tree on paper, and generating the code for a symbol would thus involve treating left branches as adding a 0 and right branches as adding a 1. In general, you would like symbols weightest heaviest to have the smallest code, since they will be encountered the most often when compressing a file. </p>
<p>It is also essential that codes cannot be confused. For example, if one symbol had the code 00 and another had the code 001 and another 1, then it would be impossible to tell in an encoding whether it means two symbols (00 and 1) or one (001). For this reason, the symbols will all need to be leaves in the tree.</p>
<p>For example: given a = 0.1, b = 0.15, c = 0.30, d = 0.16, and 3 = 0.29, then the huffman codes would be 010, 011, 11, 00, and 10, in that order.</p>
<h3 id="closest-pair-of-points"><a class="header" href="#closest-pair-of-points">Closest Pair of Points</a></h3>
<p>Given a set of points in a two dimension plane, determine which pair of points is the closest. </p>
<p>You can, of course, challenge yourself to do this in 3-dimensional space, or beyond.</p>
<h3 id="longest-increasing-subsequence"><a class="header" href="#longest-increasing-subsequence">Longest Increasing Subsequence</a></h3>
<p>Given an array of numbers, determine the start and stop index of the longest sequence of increasing numbers in the array (index <em>i</em> must be greater than index <em>i - 1</em> for each <em>i</em> in the sequence).</p>
<h3 id="longest-common-subsequence"><a class="header" href="#longest-common-subsequence">Longest Common Subsequence</a></h3>
<p>Given two strings, determine the longest substring the two share.</p>
<h3 id="hamming-distance"><a class="header" href="#hamming-distance">Hamming Distance</a></h3>
<p>Perhaps a bit trivial: Given to equal-length strings, determine how many substitutions it would take to convert one to the other.</p>
<h3 id="bipartite-matching"><a class="header" href="#bipartite-matching">Bipartite Matching</a></h3>
<p>Given <em>n</em> applicants and <em>m</em> jobs, as well as the knowledge of which jobs the applicants have applied to, determine the maxmimum number of applicants that can end up with jobs, and to which job each applicant would go in that case.</p>
<h3 id="graph-coloring"><a class="header" href="#graph-coloring">Graph Coloring</a></h3>
<p>Given a graph and <em>n</em> colors, find a way to color each vertex of the graph such that no adjacent vertices share a color.</p>
<h3 id="topological-sorting"><a class="header" href="#topological-sorting">Topological Sorting</a></h3>
<p>List the vertices of a directed acyclic graph in such a way that, for every edge <em>uv</em>, vertex <em>u</em> comes before vertex <em>v</em>. There can be more than one correct solution for some graphs.</p>
<h3 id="point-containment"><a class="header" href="#point-containment">Point Containment</a></h3>
<p>Given a series of points on a 2-dimensional plane, determine the corners of the smallest box that encapsulates all points.</p>
<p>Can you extend this to 3-dimensional space?</p>
<h3 id="point-containment-2"><a class="header" href="#point-containment-2">Point Containment 2</a></h3>
<p>Given a polgyon in a 2-dimensional plane, and a point, determine if the point is within the polgyon.</p>
<p>Can you extend this to 3-dimensional space?</p>
<h3 id="closest-point"><a class="header" href="#closest-point">Closest Point</a></h3>
<p>Given a starting point in 2-dimensional space and a list of other points in that space, determine which of the &quot;other&quot; points is closest to the starting point.</p>
<p>Can you extend this to 3-dimensional space?</p>
<h3 id="knapsack"><a class="header" href="#knapsack">Knapsack</a></h3>
<p>Given a weight limit and a list of objects that have a value and a weight, determine the maximum value of objects you can take without exceeding the weight limit.</p>
<h3 id="fizzbuzz"><a class="header" href="#fizzbuzz">FizzBuzz</a></h3>
<p>Print the numbers from 1 to 100, except print &quot;fizz&quot; instead of multiples of 3, print &quot;buzz&quot; instead of multiples of 5, and print &quot;fizzbuzz&quot; instead of multiples of both 3 and 5.</p>
<h3 id="parentheses-validation"><a class="header" href="#parentheses-validation">Parentheses Validation</a></h3>
<p>Given a string containing only parentheses, determine if each parenthese is matched correctly.</p>
<p>For example: <code>(()())((()))</code> is correct, but <code>)(())()(</code> is not. Essentially, each open parenthese must have a closed parenthese after it, and each close parenthese must have an open parenthese before it (not necessarily <em>immediately</em> before or after).</p>
<h3 id="generate-parentheses"><a class="header" href="#generate-parentheses">Generate Parentheses</a></h3>
<p>Given an integer, <em>n</em>, generate a list of all possible strings with <em>n</em> correctly matched parentheses.</p>
<p>For example: When \( n = 3 \), the possible strings will be <code>((()))</code>, <code>(()())</code>, <code>(())()</code>, <code>()(())</code>, and <code>()()()</code>.</p>
<h3 id="reverse-integer"><a class="header" href="#reverse-integer">Reverse Integer</a></h3>
<p>Given an integer, <em>n</em>, reverse its digits.</p>
<p>For example: When <em>n</em> is <code>321</code>, its reverse would be <code>123</code>.</p>
<h3 id="factor-combinations"><a class="header" href="#factor-combinations">Factor Combinations</a></h3>
<p>Given a number, <em>n</em>, find all combinations of factors of <em>n</em>, besides 1 and <em>n</em>, that can multiply to produce it.</p>
<p>For example: When <em>n</em> is <code>12</code>, the factor combinations are <code>(6, 2)</code>, <code>(3, 4)</code>, and <code>(2, 2, 3)</code>, because each of those lists contain only factors of 12, and when they are multiplied together they produce 12. NOTE: <code>(6, 2)</code> and <code>(2, 6)</code> are considered equivalent for this matter, so only one is included.</p>
<h3 id="fraction-to-recurring-decimal"><a class="header" href="#fraction-to-recurring-decimal">Fraction to Recurring Decimal</a></h3>
<p>Given a fraction with a recurring decimal, \( \frac a b \), output the decimal value, using an underscore (<code>_</code>) to represent the start of the repeating decimal.</p>
<p>For example: When <em>a</em> is <code>1</code> and <em>b</em> is <code>3</code>, output <code>0.3_</code></p>
<h3 id="anagrams"><a class="header" href="#anagrams">Anagrams</a></h3>
<p>Given two strings, determine if they are anagrams (two words that contain exactly the same letters, and the same amount of each letter to boot).</p>
<p>As an additional challenge: Given an array of strings, determine if they are all anagrams.</p>
<h3 id="longest-non-redundant-substring"><a class="header" href="#longest-non-redundant-substring">Longest Non-Redundant Substring</a></h3>
<p>Given a string, determine the starting and ending index of the longest contiguous sequence of distinct characters in the string.</p>
<p>For example: In the string <code>abacdbca</code>, we find the longest sequence of distinct characters at <code>acdb</code> (start index 2, end index 5), as well as <code>dbca</code> (start index 4, end index 7).</p>
<p>As an additional challenge: Find the longest substring with <em>at most k</em> distinct characters.</p>
<h3 id="minimum-path-sum"><a class="header" href="#minimum-path-sum">Minimum Path Sum</a></h3>
<p>Given an <em>m</em> x <em>n</em> grid of non-negative numbers, find a path from top left to bottom right which minimizes the sum of all the numbers touched along the path.</p>
<p>For example, the minimum path through</p>
<pre><code>[
    [1,3,1],
    [1,5,1],
    [4,2,1]
]
</code></pre>
<p>is (0, 0) -&gt; (0, 1) -&gt; (0, 2) -&gt; (1, 2) -&gt; (2, 2).</p>
<h3 id="tower-of-hanoi"><a class="header" href="#tower-of-hanoi">Tower of Hanoi</a></h3>
<p>Given <em>m</em> pegs and <em>n</em> discs (smallest to largest from top to bottom) which start on the first peg, determine what steps must be taken to move the discs to peg <em>k</em> and have them end up stacked in the same order in which they began.</p>
<p>There are rules for what steps you can perform, though:</p>
<ul>
<li>Only one disc can be moved at a time</li>
<li>You may only move the top-most disc on a peg</li>
<li>You may only place a disc on top of a larger disc</li>
</ul>
<p>The tower of hanoi problem specifically dictates <em>m</em> is 3, although you can challenge yourself to consider more (the same algorithm can be reused, but it could also be made more efficient).</p>
<h3 id="dining-philosophers"><a class="header" href="#dining-philosophers">Dining Philosophers</a></h3>
<p>Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers.</p>
<p>Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can only take the fork on their right or the one on their left as they become available and they cannot start eating before getting both forks.</p>
<p>Eating is not limited by the remaining amounts of spaghetti or stomach space; an infinite supply and an infinite demand are assumed.</p>
<p>The problem is how to design a discipline of behavior (a concurrent algorithm) such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming that no philosopher can know when others may want to eat or think.</p>
<p>This is more of a conceptual problem, as most programming languages have the functionality to achieve this built-in (you just have to know how to use it correctly). Concurrency was not discussed much in this guide, aside from small explaination in the design patterns chapter. For help you can research <em>semaphores</em>, <em>mutexes</em>, and <em>locks</em>.</p>
<h3 id="eight-queens"><a class="header" href="#eight-queens">Eight Queens</a></h3>
<p>Place <em>n</em> queens on an <em>n</em> x <em>n</em> chessboard such that no two queens threaten each other (no two queens share the same column, row, or diagonal).</p>
<p>If you figure out the solution by hand then it will be straightforward to convert to code, so don't try to solve the problem with guess and check as that would defeat the purpose; try to come up with an algorithmic way of arriving at the solution. Of course, reverse engineering is a valid skill so you could just ignore this advice.</p>
<h3 id="two-generals"><a class="header" href="#two-generals">Two Generals</a></h3>
<p>The two generals' problem is another real-world problem, except this time it is merely food for thought, as the problem has no solution. It is therefore not <em>really</em> a whiteboard problem, but you might still be asked about this at an interview and tricked into trying to solve it just to see your thought process.</p>
<p>Suppose there are two generals and their armies on either side of a castle, and they would like to coordinate to plan their attack, as they cannot win if only one army attacks at a time. However, it is a risky venture to contact one another as they will have to send someone through the castle grounds to the other side, and there's no guarantee that the person makes it. One general would like to start the joint attack at 8:00 am, so they send a messenger to the other general and decide &quot;if my messenger does not come back then I will send another, otherwise if my messenger comes back then I know the other general got the message&quot;. The other general receives the message and tells the messenger to return once it has responded to the first general, &quot;if the messenger does not come back then I don't know if the other general got my response--I will have to send another messenger&quot;. And so you see the conundrum. Neither general can have complete certainty that the other general is certain about the plan.</p>
<h3 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h3>
<p>Given <em>n</em> students and <em>m</em> classes with a capacity and a start/end time, and each student has a known ranking of classes they would like to take, attempt to maximize total happiness amongst by assigning students to classes. The only rules are that the classes cannot exceed their capacity, and students cannot take two classes at the same time.</p>
<p>A variation of this problem says that students need <em>k</em> minutes between classes to travel from classroom to classroom. Another says that some classes are dependent on others...this is a real-world problem so it can be extended in a lot of ways.</p>
<h3 id="jump-game"><a class="header" href="#jump-game">Jump Game</a></h3>
<p>Given an array of positive integers, determine whether the &quot;jump game&quot; will end given a starting point, <em>i</em>.</p>
<p>The jump game is where you move a number of &quot;spaces&quot; forward in the array equal to the current position you are at. The game ends if you can reach the last element of the array. The game cannot end if you are unable to move to a valid space, or if you are on a 0 which is not the last position of the array.</p>
<p>There are several variations of this problem that you can tackle:</p>
<ul>
<li>The array can contain negative integers, which will cause you to move backwards.</li>
<li>You can move a number of spaces <em>up to</em> the amount shown on your current space (absolute value to the left if using negative numbers).</li>
<li>You are allowed to move <em>past</em> the end of the array, and wrap around to the other side (in which case the game will only fail to end if you encounter a 0 or a loop).</li>
<li>You get to choose whether you want to move that many spaces forward or backward.</li>
<li>You are not only given a starting index, <em>i</em>, but also an ending index, <em>j</em> (the same rules apply, except the game only ends if you can land on <em>j</em>).</li>
<li>The game only ends when you land on a 0.</li>
</ul>
<p>The most complex ruleset for a challenge would be one in which you are given the choice of whether to move forward or backward, as well as the ability to loop around the array, as well as a target ending index.</p>
<h3 id="bit-reversal"><a class="header" href="#bit-reversal">Bit Reversal</a></h3>
<p>Given an integer, <em>n</em>, reverse its bits.</p>
<h3 id="string-permuations-around-capitals"><a class="header" href="#string-permuations-around-capitals">String Permuations Around Capitals</a></h3>
<p>Given a string, output all permutations of the string wherein capitalized letters remain in the same position.</p>
<p>For example: The string <code>abCd</code> can be permuted as itself and as <code>adCb</code>, <code>baCd</code>, <code>bdCa</code>, <code>daCb</code>, and <code>dbCa</code>.</p>
<p>A variation of this problem may have you only move numbers around within the confines of their surrounding capital letters. Other common variations simply change the pivot criteria (instead of keeping capital letters in the same place, you have to keep hyphens in the same place, and so on).</p>
<h3 id="find-duplicates"><a class="header" href="#find-duplicates">Find Duplicates</a></h3>
<p>Given an array of integers, find all duplicates (the 2nd or greater instance) of numbers in the array.</p>
<p>Challenge yourself to do this in \( O(n) \) time and \( O(1) \) wasted/extra space.</p>
<h3 id="tic-tac-toe"><a class="header" href="#tic-tac-toe">Tic-Tac-Toe</a></h3>
<p>Implement Tic-Tac-Toe with an <em>N</em> x <em>N</em> board. What this means is to produce the following outputs and take the following inputs:</p>
<pre><code>Output: What is N?
Input [integer]
Output: Would you like to play as X (go first) or O (go second)?
Input: [X or O]
// if user selects O, the program goes first and marks an empty space--in the challenge variation of this problem, the program will always make an optimal move
Output: // after every move the program should print the current state of the NxN board
// after every move the program should analyze whether there are N of one value (X or O) in a row, and if there are, output the winner
Output: Where would you like to place your mark?
Input: [(i, j), where i is the row, and j is the column]
</code></pre>
<p>A variation of this problem is: Given an <em>N</em> x <em>N</em> Tic-Tac-Toe board state, determine whether there is a guaranteed way to win for the player whose turn it is (no matter how the opponent plays, the player can win from this position). Traditionally this variation is only given for 3x3 Tic-Tac-Toe, so you can start with the assumption that <em>N</em> is always 3, and then try to program for a generic <em>N</em>.</p>
<h3 id="indexed-binary-string"><a class="header" href="#indexed-binary-string">Indexed Binary String</a></h3>
<p>Given an index, <em>k</em>, find the \( k^{th} \) digit in a binary string. The binary string will be defined as follows:</p>
<pre><code>binString = &quot;0&quot;;
binString = binString + ~binString; // recall ~ is the NOT operator in some languages
binString = binString + ~binString;
// etc.
</code></pre>
<p>Thus the binary string ends up being 0 -&gt; 01 -&gt; 0110 -&gt; 01101001 -&gt; 0110100110010110...</p>
<p>To provide a more formal definition of the binary string <em>is</em> the problem.</p>
<h3 id="relationships"><a class="header" href="#relationships">Relationships</a></h3>
<p>Consider the following code (this intentionally contains oddities that don't exist in most langauges):</p>
<pre><code>Class Person {
    Public Person mom;
    Public Person dad;
    Public Person children[];

    Public static bool areRelated(Person p1, Person p2, int gens) {
        /* gens = number generations removed the two people must be within in order to be considered &quot;related&quot; */
    }
}
</code></pre>
<p>Your goal is to implement areRelated(...). It should return whether or not the two people are related, based on the generational threshold.</p>
<p>The simple solution to this may yield a lot of wasted space or extraneous recursive calls for high values of <code>gens</code>. Try to think of a way to minimze that cost (of course, you may have already done it in your first solution, so don't spend too much time on this if you can't figure it out!).</p>
<h3 id="php-exploit"><a class="header" href="#php-exploit">PHP Exploit</a></h3>
<p>Consider the following code:</p>
<pre><code>$pin = $_GET['PIN'];
$cmd = 'sudo testcode.py $pin;';
exec($cmd);
</code></pre>
<p>How can someone remove all files from the host machine if a web app contains this code?</p>
<p>Followup question: How do you know the system will allow you to run this code without prompting you for an admin password?</p>
<h3 id="prime-sum"><a class="header" href="#prime-sum">Prime Sum</a></h3>
<p>Given an even number greater than 2, validate that it is the sum of 2 primes (this is a true fact) by finding those 2 primes and printing them. NOTE: 1 is not considered a prime number.</p>
<h3 id="odd-one-out"><a class="header" href="#odd-one-out">Odd One Out</a></h3>
<p>Given a sorted list within which there are exactly two copies of each element, except for one, find which element is the one without a copy.</p>
<p>There is a simple solution to this problem that can be performed in \( O(n) \) time. Your goal is to solve this problem in \( O(\log n) \) time.</p>
<h3 id="greatest-common-denominator"><a class="header" href="#greatest-common-denominator">Greatest Common Denominator</a></h3>
<p>Find the greatest common denominator of 2 numbers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions-to-ask"><a class="header" href="#questions-to-ask">Questions To Ask</a></h1>
<p>When it's your turn to ask questions, I've come up with some good (in my opinion) ones. While it's true that <em>having</em> questions might make you look better, it probably doesn't matter much what the questions are, so unlike the other pages, this one isn't meant to be a guide or wiki.</p>
<p>Note: Questions about salary, benefits, etc. should be saved for after you've been offered the job. This is not a resource for negotiation tactics, although such resources do exist.</p>
<p>Note: If the answer to any of these questions is available on the company's website or was included in the job description, then don't ask it; It might just make you look worse for not knowing what you're applying for.</p>
<p><strong>Q:</strong> What software development workflows and frameworks do you use?
<br>
<i>Workflows = tools, procedures, etc.</i>
<br>
<i>Frameworks = waterfall, agile, scrum, etc.</i></p>
<br>
<p><strong>Q:</strong> What sorts of projects could I expect to be a part of if I were to work here?</p>
<br>
<p><strong>Q:</strong> What are parts of the job that you enjoy? (Alternatively: What's your favorite part of working here?)
<br>
<i>Not applicable to interviewers who are not in the position you're applying for...</i></p>
<br>
<p><strong>Q:</strong> What does a typical work day look like for you? (How much of your day is spent coding? How many meetings do you have every week?)
<br>
<i>Again: probably not relevant to ask people who aren't in the position you're applying for...</i></p>
<br>
<p><strong>Q:</strong> What technology stacks do you use?</p>
<br>
<p><strong>Q:</strong> What are some challenges that might be faced by someone just starting to work here?</p>
<br>
<p><strong>Q:</strong> I know that you guys deal in X (e.g. scalability). Are there opportunities within the company to learn more about X? Should I prepare myself with knowledge of X if I were to work here?</p>
<br>
<p><strong>Q:</strong> Could you tell me more about X that you use?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h1>
<h3 id="books"><a class="header" href="#books">Books</a></h3>
<p>Laakmann, Gayle. <em>Cracking the Coding Interview</em></p>
<p>Martin, Robert C. <em>Clean Code</em></p>
<p>Gamma, Helm, Johnson, and Vlissides. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em></p>
<p>Cormen, Leiserson, Rivest, and Stein. <em>Introduction to Algorithms</em></p>
<p>Abelson, Sussman, and Sussman. <em>Structure and Interpretation of Computer Programs</em></p>
<p>Knuth, Donald. <em>The Art of Computer Programming</em></p>
<p>Stroustrup, Bjarne. <em>The C++ Programming Language</em></p>
<p>Shotts Jr., William E. <em>The Linux Command Line</em></p>
<p>Hunt and Thomas. <em>The Pragmatic Programmer: From Journeyman to Master</em></p>
<p>Brooks, Frederick. <em>The Mythical Man-Month</em></p>
<p>&quot;The Agile Manifesto&quot;, <a href="https://agilemanifesto.org/">https://agilemanifesto.org/</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
